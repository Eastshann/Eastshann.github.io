[{"title":"Redis Stream 消息队列","path":"/2026/01/06/Redis-Stream-消息队列/","content":"持久化Redis Stream 主要用于消息队列（MQ，Message Queue）。与传统的 PubSub（发布订阅）那种“阅后即焚”的模式不同，Redis Stream 的持久化可以通过以下三个核心维度来体现： 1.消息的物理持久化 (RDBAOF)Redis Stream 的数据结构是作为 Redis Key 存储在内存中的。这意味着它直接受 Redis 自身的持久化机制保护： AOF (Append Only File)： 每当你执行 XADD 写入一条消息时，Redis 会将该指令记录到 AOF 日志中。即使 Redis 宕机，重启后也会通过回放 AOF 恢复所有的消息。 RDB (Snapshot)： 定时将内存中的 Stream 数据生成快照保存到磁盘。 对比： PubSub 只是内存中的实时转发，不占用空间也不存入磁盘，一旦重启，未消费的消息彻底消失。 2.消费进度的持久化 (Consumer Group Offset)这是 Redis Stream 作为 MQ 最强大的地方。它能记录每个消费者组看到哪儿了。 状态存储： 消费者组的 last_delivered_id（最后交付 ID）是持久化的。 体现： 如果你的消费者程序崩溃了，重启后只需再次连接，Redis 会告诉它从上次断开的位置继续消费，而不会丢失中间产生的消息。 3.消息确认与待处理列表 (PEL - Pending Entries List)edis Stream 保证消息“不丢失”不仅是靠存入磁盘，还靠可靠交付机制： PEL 机制： 当消费者读取消息但尚未发送 XACK（确认）时，Redis 会在内部的 PEL 列表中持久化记录这条消息。 体现： 如果消费者拉取了消息但处理到一半宕机了，这条消息依然在 Redis 的 PEL 中。下次启动时，可以通过 XPENDING 指令找回这些“处理中”的消息进行重试。 结构Redis Stream 的结构如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容： 每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。 Consumer Group 是消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者（Consumer）。 last_delivered_id 是游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。 pending_ids 是消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。"},{"title":"Redis入门","path":"/2025/12/27/Redis入门/","content":"一、引言Redis 是一个基于内存的高性能键值数据库，支持多种数据结构，常用于缓存、消息队列和实时数据处理。 二、安装https://github.com/tporadowski/redis/releases 三、数据类型3.1 string（字符串）（1）根据键获取值不存在则返回nil get key （2）根据多个键获取多个值get key key key （3）设置键值set key value （4）设置多个键值set key value key value key value （5）判断键值是否存在setnx key value 用处： 分布式锁 操作 redis 之前先用 setnx 检查 flag，返回为1，则可以操作。操作结束后删除 flag。 （6）设置键值过期时间set key second value （7）删除键值del key （8）字符串拼接值append key value （9）自增自减set count 0incr countget count\t# 1decr countget count\t# 0incrby count 10get count # 10decrby count 10get count\t# 0 （10）字符串长度strlen key （11）比特流操作setbit key offset value\t# 设置比特中某个偏移的值getbit key offset # 查看比特中某个偏移的值bitcount key # 比特中设为1的数量 3.2 key 操作（1）查找键参数支持简单的正则表达式 keys pattern （2）判断键是否存在存在返回1，不存在返回0 exists key （3）查看值的数据类型type key （4）删除键del key key key ... （5）查看键的有效期返回结果是秒为单位的整数 -1 表示永不过期， -2 表示当前数据已经过期，查看一个不存在的数据的有效期就是 -2 ttl key （6）设置 key 有效期给已有的数据重新设置有效期，有效期到了，数据就会被删除 expire key seconds （7）清空所有 keyflushall （8）key 重命名rename oldkey newkey （9）select 切换数据库redis 的配置文件中，默认有0-15之间的16个数据库，默认操作的就是0号数据库 select 数据库ID 3.3 list 数组注意：list 的子成员类型为 string （1）添加子成员# 在左边添加lpush key value value value# 在右边添加rpush key value value value# 在指定元素的左边/右边插入一个数据linsert key before 指定元素 valuelinsert key after 指定元素 value （2）获取列表成员根据指定的索引（下标）获取成员的值，负数下标从右边-1开始，逐个递减 lindex key index （3）获取列表切片闭区间包括 stop lrange key start stop （4）获取列表长度llen key （5）按索引设置值lset key index value （6）删除指定成员lpop key\t# 第一个成员出列, 并返回它rpop key\t# 最后一个成员出列, 并返回它 # count = 0 表示删除列表所有值为 value 成员# count 0 表示删除列表左侧开始的前 count 个 value 成员# count 0 表示删除列表右侧开始的前 count 个 value 成员lrem key count value 3.4 hash（哈希）key:\tfield1:value1\tfield2:value2\tfield3:value3 （1）设置指定键的属性域设置指定键的的单个属性 hset key field value field value field value ... （2）获取指定键的域属性的值hget key field value （3）获取指定键的所有键值hkeys keyhvals key （4）获取哈希的所有域值对hgetall key （5）删除指定键的域属性hdel key field field field ... （6）判断指定属性域是否存在于当前键对应的hash中hexists key field （7）属性值自增自减hincrby key fieldhdecrby key field 3.5 set（集合）去重、无序 （1）添加元素sadd key member member member ... （2）获取集合所有的成员smembers key （3）获取集合的长度scard key （4）随机抽取一个或多个元素spop key [count=1] （5）删除指定元素srem key value （6）交集、差集和并集# 交集sinter key key# 差集sdiff key key# 并集sunion key key 3.6 zset（有序集合）有序集合(scorevalue)去重并且根据 score 权重值来进行排序的。score 从小到大排列。 （1）添加成员 zadd key score member score member score member ... （2）获取 score 在指定区间的所有成员 # 按 score 进行从低往高排序获取指定 score 区间zrangebyscore key min_score max_score# 按 score 进行从高往低排序获取指定 score 区间zrevrangebyscore key min_score max_score# 按 score 进行从低往高排序获取指定索引区间, 0 -1 表示从低到高全部成员zrange key start_idx stop_idx# 按 scoer 进行从高往低排序获取指定索引区间zrevrange key start_idx stop_idx （3）获取集合长度 zcard key （4）获取指定成员的权重值 zscore key member （5）获取指定成员在集合中的排名 # 从低到高排zrank key member# 从高到低排zrevrank key member （6）获取 score 在指定区间的所有成员的数量 zcount key min max （7）给指定成员增加权重值 zincrby key score member （8）删除成员 zrem key member member member ... （9）删除指定数量的成员 # 删除指定数量的成员，从最低 score 开始删除zpopmin key [count]# 删除指定数量的成员，从最高 score 开始删除zpopmax key [count]","tags":["中间件"]},{"title":"2025 从 OpenCV 到 ROS 机器人的一年","path":"/2025/12/20/2025-这一年/","content":"2025年的工作内容变化很大，从一个写 OpenCV 传统图像算法的算法助理，变成了 ROS 机器人开发工程师（大概？）。这一切都要从25年3月开始说起。 公司裁员持续了大半年的广州出差，似乎终于要因为公司不愿再增加项目成本而结束。到3月底公司就会退出广州的项目，对于我来说这是是一个不折不扣的好消息，这意味着我终于不用每个月去广州出差3周，回来休息一周了。 但遗憾的是事情往往不会朝你希望的方向发展，公司确实会在3月底退出广州项目，但项目不能结束不然领导的客户关系就黄了，这会直接影响到和甲方的另一个大项目。于是乎我们整个项目组私下还在支持着这个项目（有偿）。大部分同事远程支持，而我要再去那边呆一个月不然就露馅了（甲方并不知道公司撤离了）。 那么问题来了，公司既然已经退出了项目，我以什么名义出差去广州呢？经理安排我用去广州另一个客户那交接的名义去广州，去是去了，但综合管理那边不允许我长期滞留在广州。于是只好请假一个月，在广州项目这边继续支持。 漫长的一个月终于结束，我终于回到了常熟。公司流传出因为业务调整要不我们整个部门裁掉，部长私下里也提醒我们抽空抓紧找工作。找工作是一个很麻烦的事情，我在广州写了大半年的 OpenCV，如果要找新工作我该干什么呢？继续写 OpenCV吗？接下来的两个月我们部门都很清闲没有任何任务。每天就是上班打卡，坐在工位上做自己的事情学技术或者玩手机，中午悠哉的睡两个小时也没人会说你，下午依旧很悠闲等待下班打卡。偶尔会被销售找去帮忙布置展会，此外大概也就没什么了。 该来的终究还是会来，大概6月初的样子综合管理挨个找我们部门谈话了，人事直接和我说了公司准备裁员了赔偿的话只能给到0.5n+1，签了离职协议后再过几天就不用来公司上班打卡了，考勤会给我算到月底。我呢懒得和公司谈赔偿了感觉也谈不赢，仲裁我也没时间耗着后面还要找工作，直接就签了。 时来运转签完离职协议的第二天，隔壁办公室的销售同事找我聊天，他听说了我们部门的事情，正好公司前 CTO 那边缺一个搞图像算法的，公司在杭州做机器人相关，问我有没有兴趣有的话发他一份简历。我当然说有啊，刚被开就有内推，这不是瞌睡了有人给你送枕头嘛。之后第二天就安排了面试，一共两轮技术面+人事面。人事面的时候问我期望薪资是多少，我说去年平均月薪在8k出头（不出差我只有7k月薪，但大半年都在出差）希望这份工作能有1w。很幸运过几天就收到 offer 了，其实我当时报1w的时候还是挺紧张的。 时不待我，面试时候说随时可以离开现单位，那边让我一周后就报道。好吧找房子吧，我加了自如平台的客服用微信视频带我远程看房，定好房子后过了三四天便从常熟搬去了杭州。和朋友聊天的时候发现他也来杭州了，比我早一个月。他是做后端开发的从 JAVA 转 Go 了。我们俩约时间逛了逛杭州，去吃了之前一直想尝尝的蟹黄面（很鲜但没有想象中那么惊艳），又在下雨天逛了逛西湖，烟雨西湖确实很有意境。之后还有一天去他住处，露了一手厨艺哈哈哈。在他推荐下，我把罗小黑动漫、漫画还有大电影都看了一遍，一起去电影院看了罗小黑2。 同事跑路到了杭州后，和我搭档的同事负责机器人的机械臂控制开发，而我负责机器人的视觉算法。私下和同事聊天发现他和我同届，本科学的网络安全，大四报了嵌入式的培训班，毕业找了份嵌入式开发的工作。两个月相处下来感觉他工作有点奇怪总是不上心，月度汇报也没什么成果。月底还有几天他就要转正了，好家伙他和我说准备提离职了。这三个月他花了一两万在学大模型应用开发，Agent、RAG、LoRa微调这些，上周拿了一个15k的offer准备跑路了。这哥们走了后，公司似乎也没准备再招机械臂控制的人，领导让我和他交接一下，视觉先放放接手他的项目继续做下去。我的天我哪里懂机械臂控制。而且接手了后才发现这哥们三个月啥也没做成，代码运行起来根本用不了。 搞机械臂说搞就搞，什么相机标定、正运动学、逆运动学、ROS2 开发、VR 遥操猛猛看。公司采购的人形机器人到了后，就开始研究里面的遥操代码，一边看一边复刻。国庆前机器人送回去维修了一次，维修完发现他们竟然把遥操代码编译了，但git修改记录没删哈哈哈哈哈。我继续一边看一边复刻。每天上班两眼一睁就是看他们的遥操代码，研究整个系统是怎么运行的，控制机械臂的逻辑是什么。中间还被调去数字人 Agent 项目做了一个月 agent 开发。等回到机械臂这边代码都忘的差不多了，真的裂开。花了大概有4个月，基本上是把机器人的遥操系统给抄完了开发完了。剩下就是怎么做WebRTC视频流传输实现局域网下远程操控了。 上周和领导汇报完进度后，了解到公司可能不会再在机器人上投入更多的成本了，当然这个项目要做完不能烂尾。年底有客人来公司，还要做演示。等机器人项目做完后，应该会把我调去别的项目，大概是生成式 AI 相关。说实话我个人现在不太准备 AI 算法这个方向上继续走下去了。前公司部长最近也来杭州工作了，和他见了个面聊了聊对智能体的看法。他的看法是国内智能体大概是在 DeepSpeek 爆火之后大家开始都在做，现在处于一个野蛮生长的状态，谁也不知道哪种模式会成功。可能未来两到三年，智能体或者大模型应用开发的岗位会少一大半。成功的商业模式被摸索出来后大家都开始抄，对这个岗位的需求就不像现在这么多了。 未来规划毕业出来工作也差不多一年半了，未来发展我是准备往后端+大模型应用的方向发展，算法很有前途但我做算法没有前途（本科不太行外加没有硕士学历）。正好最近朋友拉我帮他做开源的 Go 微服务社区系统项目，我也就开始看 Go 了。认识的两个后端都是 Go 开发，JAVA还是太卷了。总之，先在公司干着积累工作经验，有空就学习后端技术，多掌握一门技术总归不是坏事。","categories":["日常"]},{"title":"手动编译 nlopt 并在 pip list 中注册","path":"/2025/09/02/手动编译-nlopt-并在-pip-list-中注册/","content":"git clone https://github.com/stevengj/nlopt.git cd nlopt mkdir build cd build # 安装 SWIG（用于生成 Python 绑定）sudo apt-get updatesudo apt-get install swig cmake .. \\ -DNLOPT_PYTHON=ON \\ -DPython_EXECUTABLE=$(which python) \\ -DPython_NumPy_INCLUDE_DIRS=$(python -c import numpy; print(numpy.get_include())) makesudo make install # 查看是否生成了 Python 相关文件find . -name *python* -o -name *.py -o -name *.so # 进入 Python 绑定目录cd src/swig/python# 查看目录内容ls -la# 安装 Python 绑定pip install .","tags":["pip"],"categories":["开发工具与版本控制"]},{"title":"ROS2服务和参数","path":"/2025/09/01/ROS2服务和参数/","content":"1. 创建服务接口包命令 ros2 pkg create face_interfaces \\--build-type ament_cmake \\--dependencies rosidl_default_generators sensor_msgs \\--license Apache-2.0 依赖：rosidl_default_generators 类型：ROS 2 的 CMake 包（CMake package） 作用：生成 ROS 2 消息、服务和动作所需的 接口代码。 功能： 当你定义一个 .msg、.srv 或 .action 文件时，rosidl_default_generators 会负责生成对应的语言绑定（C++、Python 等）。 没有它，ROS 2 无法把你写的消息文件转换成可以在节点里直接用的类。 依赖：sensor_msgs 类型：ROS 2 消息包（message package） 作用：提供标准化的传感器数据消息类型。 包含的消息： Image：相机图像 CameraInfo：相机内参 LaserScan：激光雷达扫描 Imu：惯性测量单元数据 等等 CMakeLists.txt rosidl_generate_interfaces( $PROJECT_NAME srv/FaceDetector.srv DEPENDENCIES sensor_msgs) package.xml member_of_grouprosidl_interface_packages/member_of_group 查看信息 ros2 interface show face_interfaces/srv/FaceDetector","tags":["ros2"],"categories":["机器人"]},{"title":"ROS2订阅和发布","path":"/2025/08/31/ROS2订阅和发布/","content":"ROS2订阅和发布自定义消息类型打开终端在ros2_ws/src下输入命令 ros2 pkg create status_interfaces \\--build-type ament_cmake \\--dependencies rosidl_default_generators builtin_interfaces \\--license Apache-2.0 上面的指令用于创建一个名叫 status_interfaces 的功能包，并为其添加 builtin_interfaces 和 rosidl_default_generators 两个依赖。builtin_interfaces 是 ROS2 中已有的一个消息接口功能包，可以使用其时间接口Time，表示记录信息的时间。 rosidl_default_generators 用于将定义的消息文件转换为 C++、Python 源码的模块。 ROS2 中话题消息定义文件需要放置在功能包的 msg 目录下，文件名必须以大写字母开头，且只能是大写小写以及数字组成。接着在功能包下创建 msg 目录,并在该目录下新建文件 SystemStatus.msg 。 builtin_interfaces/Time stamp # 记录时间戳string host_name # 系统名称float32 cpu_percent # cpu使用率float32 memory_percent # 内存使用率float32 memory_total # 内存总量float32 memory_available # 剩余有效内存float64 net_sent # 网络发送数据总量float64 net_recv # 网络接收数据总量 ros2 消息接口支持的数据类型共有9种： bool byte char string float32，float64 int8，unint8 int16，unint16 int32，unint32 int64，unint64 定义好数据接口文件后，需要在 CMakeLists.txt 中对该文件进行注册，声明其为消息接口文件，并为其添加 builtin_interfaces 依赖, cmake_minimum_required(VERSION 3.8)project(status_interface)if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES Clang) add_compile_options(-Wall -Wextra -Wpedantic)endif()# find dependenciesfind_package(ament_cmake REQUIRED)find_package(rosidl_default_generators REQUIRED)find_package(builtin_interfaces REQUIRED)# 注册rosidl_generate_interfaces($PROJECT_NAME msg/SystemStatus.msg DEPENDENCIES builtin_interfaces)if(BUILD_TESTING) find_package(ament_lint_auto REQUIRED) # the following line skips the linter which checks for copyrights # comment the line when a copyright and license is added to all source files set(ament_cmake_copyright_FOUND TRUE) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a copyright and license is added to all source files set(ament_cmake_cpplint_FOUND TRUE) ament_lint_auto_find_test_dependencies()endif()ament_package() 在功能包清单文件 package.xml 中添加申明。在package.xml 中添加 member_of_group 是为了声明该功能包是一个消息接口功能包，方便 ROS 2对其做额外处理。 ?xml version=1.0??xml-model href=http://download.ros.org/schema/package_format3.xsd schematypens=http://www.w3.org/2001/XMLSchema?package format=3 namestatus_interface/name version0.0.0/version descriptionTODO: Package description/description maintainer email=root@todo.todoroot/maintainer licenseApache-2.0/license member_of_grouprosidl_interface_packages/member_of_group buildtool_dependament_cmake/buildtool_depend dependrosidl_default_generators/depend dependbuiltin_interfaces/depend test_dependament_lint_auto/test_depend test_dependament_lint_common/test_depend export build_typeament_cmake/build_type /export/package 接着来构建功能包，构建完成后，可以使用的命令来确定消息接口是否构建成功。 sourse install/setup.bashros2 interface show status_interfaces/msg/SystemStatus 显示： (ros2) root@GuFan:~/Desktop/ros2_ws# ros2 interface show status_interfaces/msg/SystemStatusbuiltin_interfaces/Time stamp # 记录时间戳 int32 sec uint32 nanosecstring host_name # 系统名称float32 cpu_percent # cpu使用率float32 memory_percent # 内存使用率float32 memory_total # 内存总量float32 memory_available # 剩余有效内存float64 net_sent # 网络发送数据总量float64 net_recv # 网络接收数据总量 系统信息的获取与发布在 src 目录下创建 status_publisher 功能包，并在功能包对应目录下创建 sys_status_pub.py 文件， 并添加消息接 口 status_interfaces 和客户端库 relpy 作为其依赖。 ros2 pkg create status_publisher \\--build-type ament_python \\--dependencies rclpу status_interfaces \\--license Apache-2.0 代码如下： import rclpyfrom rclpy.node import Nodefrom status_interface.msg import SystemStatusimport psutilimport platformclass SysStatusPub(Node): def __init__(self, node_name): super().__init__(node_name) self.status_publisher_ = self.create_publisher( SystemStatus, sys_status, 10) self.timer = self.create_timer(1, self.timer_callback) def timer_callback(self): cpu_percent = psutil.cpu_percent() memory_info = psutil.virtual_memory() net_io_counters = psutil.net_io_counters() msg = SystemStatus() msg.stamp = self.get_clock().now().to_msg() msg.host_name = platform.node() msg.cpu_percent = cpu_percent msg.memory_percent = memory_info.percent msg.memory_total = memory_info.total / 1024 / 1024 msg.memory_available = memory_info.available /1024 /1024 msg.net_sent = net_io_counters.bytes_sent / 1024 / 1024 msg.net_recv = net_io_counters.bytes_recv / 1024 / 1024 self.get_logger().info(f发布：str(msg)) self.status_publisher_.publish(msg) def main(): rclpy.init() node = SysStatusPub(sys_status_pub) rclpy.spin(node) rclpy.shutdown() 在 setup.py 中对 sys_status_pub 节点进行注册。 from setuptools import find_packages, setuppackage_name = status_publishersetup( name=package_name, version=0.0.0, packages=find_packages(exclude=[test]), data_files=[ (share/ament_index/resource_index/packages, [resource/ + package_name]), (share/ + package_name, [package.xml]), ], install_requires=[setuptools], zip_safe=True, maintainer=root, maintainer_email=root@todo.todo, description=TODO: Package description, license=Apache-2.0, tests_require=[pytest], entry_points= console_scripts: [ sys_status_pub = status_publisher.sys_status_pub:main ], ,) 运行 ros2 run status_publisher sys_status_pub 打开新的终端，依次输入命令： source install/setup.bashros2 topic echo /sys_status 到这里，便把系统状态获取以及发布部分完成了。 报错记录 ImportError: /root/miniconda3/envs/ros2/bin/../lib/libstdc++.so.6: version GLIBCXX_3.4.30’ not found 意思：你的 Conda 环境里的 libstdc++.so.6 太旧，没有 GLIBCXX_3.4.30 这个符号（ROS 2 Jazzy 的 rclpy 模块需要）。 原因：ROS 2 Jazzy 本身是基于 系统的 GCClibstdc++ 编译的。在 conda 环境里运行时优先加载了conda的libstdc++.so.6。结果就是版本对不上。 解决方法：强制使用系统的 libstdc++ export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 订阅消息并通过QT显示新建功能包 ros2 pkg create status_display \\--build-type ament_cmake \\--dependencies rclcpp status_interfaces \\--license Apache-2.0 在 srcstatus_displaysrc 下新建 sys_status_display.cpp ，编写代码。 #include QApplication#include QLabel#include QString#include rclcpp/rclcpp.hpp#include status_interfaces/msg/system_status.hppusing SystemStatus = status_interfaces::msg::SystemStatus;class SysStatusDisplay : public rclcpp::Node public: SysStatusDisplay() : Node(sys_status_display) // 创建一个订阅者，订阅话题 sys_status，队列长度为 10 // 当收到消息时，执行 回调函数（这里用 C++ lambda），更新 QLabel 的文字 subscription_ = this-create_subscriptionSystemStatus( sys_status, 10, [](const SystemStatus::SharedPtr msg) - void label_-setText(get_qstr_from_msg(msg)); ); // 创建一个空的 SystemStatus 对象，转化成 QString 进行显示 label_ = new QLabel(get_qstr_from_msg(std::make_sharedSystemStatus())); label_-show(); QString get_qstr_from_msg(const SystemStatus::SharedPtr msg) std::stringstream show_str; show_str ===========系统状态可视化显示工具============ 数 据 时 间:\\t msg-stamp.sec \\ts 用 户 名:\\t msg-host_name \\t CPU使用率:\\t msg-cpu_percent \\t% 内存使用率:\\t msg-memory_percent \\t% 内存总大小:\\t msg-memory_total \\tMB 剩余有效内存:\\t msg-memory_available \\tMB 网络发送量:\\t msg-net_sent \\tMB 网络接收量:\\t msg-net_recv \\tMB ==========================================; return QString::fromStdString(show_str.str()); private: rclcpp::SubscriptionSystemStatus::SharedPtr subscription_; QLabel* label_;;int main(int argc, char* argv[]) // 初始化 ROS2 rclcpp::init(argc, argv); // 初始化 Qt 应用 QApplication app(argc, argv); // 创建节点对象 auto node = std::make_sharedSysStatusDisplay(); // 启动一个新线程来 spin ROS2 std::thread spin_thread([]() - void rclcpp::spin(node); ); spin_thread.detach(); // 运行 Qt 的事件循环（窗口保持运行） app.exec(); // Qt 退出后关闭 ROS2 rclcpp::shutdown(); return 0; ROS2 的 spin 会阻塞，所以单独开一个线程执行 rclcpp::spin(node)。进入 Qt 的事件循环，显示窗口。当窗口关闭时，停止 ROS2。","tags":["ros2"],"categories":["机器人"]},{"title":"ros2基础入门","path":"/2025/08/30/ros2基础入门/","content":"ros2基础入门创建功能包一个完整的机器人往往由多个功能模块组成，需要多个功能包进行组合。ROS2开发者约定了Workspace（工作空间）这个概念来管理多个功能包。 首先创建工作空间，在开发过程中，所有的功能包都放在src目录下，并在src同级目录也就是ros2_ws目录下运行colcon进行构建，此事构建出的build、install、log等目录和src保持同级。 mkdir -p ros2_ws/srccd ros2_ws/src 在src目录下创建C++功能包 ros2 pkg create pkg_name --build-type ament_cmake --license Apache-2.0cd pkg_name/src ros2 pkg create是用于创建功能包的命令，其中pkg_name是功能包的名字，后面的--build-type ament_cmake表示指定功能包的构建类型为ament_cmake即C++，最后的--license Apache-2.0用于声明功能包的开源协议。 创建好功能包后，在功能包的src目录下添加cpp_node.cpp（举例，根据实际情况取不同名字） #include rclcpp/rclcpp.hppint main(int argc, char **argv) rclcpp::init(argc, argv); auto node = std::make_sharedrclcpp::Node(cpp_node); RCLCPP_INFO(node-get_logger(), 你好 C++ 节点！); rclcpp::spin(node); rclcpp::shutdown(); return 0; 代码编写完成后，还需要在CMakeLists.txt文件中注册节点，添加依赖 ...find_package(ament_cmake REQUIRED)// 查找rclcpp头文件和库find_package(rclcpp REQUIRED)// 添加可执行文件cpp_nodeadd_executable(cpp_node src/cpp_node.cpp)// 为cpp_node添加依赖ament_target_dependencies(cpp_node rclcpp)// 将cpp_node添加到install目录install(TARGETScpp_nodeDESTINATION lib/$PROJECT_NAME)... 构建功能包前还需要在清单文件packages.xml中添加对relcpp的依赖声明 dependrclcpp/depend 最后使用colconb build构建功能包，该命令可以构建当前及子目录下所有功能包。若构建时当前目录下不存在build、install和log这三个目录，则会自动创建,并将构建中间文件、结果和日志放入对应目录中。构建完成后,再查看 installdemo_cpp_pkglibdemo_cpp_pkg目录就可以看到cpp_node 可执行文件 了。 colcon build 依次输出两条指令，就可以运行该文件 source install/setup.bashros2 run demo_cpp_pkg cpp_node 功能包结构 include 该目录用于存放 C++ 的头文件,如果要编写头文件,一般 都放置在这个目录下。 src 代码资源目录,可以放置节点或其他相关代码。 CMakeLists.txt 该文件是 CC++ 构建系统 CMake 的配置文件，在该文件中添加指令，即可完成依赖查找、可执行文件添加、安装等工作。 LICENSE 该文件是功能包的许可证。创建该功能包时使用了 –license Apache-2.0 参数,这个文件內容就是 Apache-2.0 的协议内容 package.xml 该文件是功能包的清单文件，每个 ROS2 的功能包都会包含这个文件。 当然，除了上面这些文件和文件夹,在实际开发中还可以添加其他目录和文件,比如用 于放置地图的 map 目录、用于放置参数的 config 目录等。","tags":["ros2"],"categories":["机器人"]},{"title":"基于局部点云特征匹配的6D姿态估计方案","path":"/2025/08/27/基于局部点云特征匹配的6D姿态估计方案/","content":"最近项目上需要程序可以快速估算出目标的位姿，并且要有较高的泛化性。简单说就是不需要提前建立完整的CAD模型，只需要拍几张多角度图片就可以，通过纹理匹配，估算出目标位姿。查阅了几天资料，理了一下初步思路： 首先6D位姿是指一个刚体在三维空间中的位置和姿态。具体来说它包含6个自由度（6 Degrees of Freedom, 6 DoF）。位置：x，y，z的，这三个量决定了物体在空间中的坐标位置。姿态：roll，pitch，yaw，这三个量分别是绕x、y、z的旋转量，描述物体的朝向。通常在数学上用齐次变换矩阵来表示6D位姿。 位置xyz的获取通过检测分割模型进行定位，姿态rpy通过局部特征点匹配+PnP解算得出。 准备工作： 一台深度相机 一个检测分割模型 第一步： 假设目标是一个方体有前后左右上下六个面，从斜上方拍摄确保能得到3个面的点云。根据分割结果，提取目标RGB图做为模板图，和目标点云。 第二步： 提取模板图特征点，和对应的3D坐标。 第三步： 计算目标点云的OBB有向包围盒，得出包围盒在OBB坐标系下的最小点、最大点、世界坐标系下包围盒的中心的坐标，以及OBB坐标系到世界坐标系的旋转矩阵R。其中世界坐标系下包围盒的中心的坐标等价于OBB坐标系到世界坐标系的平移矩阵t。 第四步： 通过对旋转平移矩阵的逆变换，将模板图特征点的3D坐标从世界坐标系变换到OBB坐标系。 第五步： 拍摄一张目标图片，根据分割结果提取目标作为目标图。目标点云的平均xyz作为位置。计算目标图特征点和模板图特征点匹配，得出目标图2D特征点-模板图3D特征点的2D-3D点对。 第六步： 用PnP算法结算2D-3D点对，得出相机坐标系到OBB坐标系的旋转平移矩阵，将坐标轴和包围盒投影到图片上。","tags":["3D点云"],"categories":["机器视觉"]},{"title":"点云OBB有向包围框处理思路","path":"/2025/08/27/点云OBB有向包围框处理思路/","content":"最近在做点云中的OBB算法工作，给定一个物体的点云，快速估计出物体的有向包围框。算法的主要原理是PCA（Principal Component Analysis，主成分分析），是数据分析的一种重要技术。它可以将高维数据投影到低维空间，找到数据的主要结构。在点云场景下，PCA用来提取点云的主成分方向和法向量方向。 PCL库已经实现好了OBB相关算法（pcl::MomentOfInertiaEstimation），MomentOfInertiaEstimation 类可以计算点云的 惯性矩、重心、主方向，同时可以得到 AABB（轴对齐包围盒）和OBB（方向对齐包围盒）。它内部会用点云的质心和协方差矩阵来求解主方向，从而得到有向包围盒。 注意1：该接口为模板函数，因为没有预编译pcl::PointXYZRGB类型的版本，编译时会报错。建议使用pcl::PointXYZ类型 注意2：该接口计算出的OBB不一定是最小包围盒 使用说明 // 头文件#include pcl/features/moment_of_inertia_estimation.h// 创建特征提取器对象，传入点云并计算pcl::MomentOfInertiaEstimationpcl::PointXYZ feature_extractor;feature_extractor.setInputCloud(cloud_filtered);feature_extractor.compute();// 存储结果pcl::PointXYZ min_point_OBB, max_point_OBB, position_OBB;Eigen::Matrix3f rotational_matrix_OBB;feature_extractor.getOBB(min_point_OBB, max_point_OBB, position_OBB, rotational_matrix_OBB); 计算结果： min_point_OBB ：在 OBB坐标系下 的最小点坐标（即包围盒的八个顶点之一）。 max_point_OBB：在 OBB坐标系下 的最大点坐标（即包围盒的八个顶点之一）。 position_OBB：OBB 的中心点（世界坐标系下）。同时也是OBB坐标系到世界坐标系的平移量。 rotational_matrix_OBB：OBB 的旋转矩阵，用于把 OBB坐标系 转换到 世界坐标系。 有了OBB坐标系到世界坐标系的旋转平移矩阵后，就可以把OBB变换到世界坐标系下去包围住点云，或者将点云逆变换到OBB坐标系 下填入包围盒内。在可视化窗口内绘制包围盒，可以使用pcl::visualization::PCLVisualizer类的addCube函数，addCube有三种重载形式。 addCube(x_min, x_max, y_min, y_max, z_min, z_max, r, g, b, id); 优点：简单，直接用坐标画。 缺点：无法指定旋转，立方体总是平行于世界坐标轴。 addCube(const pcl::ModelCoefficients coefficients, id, viewport); coefficients 是长度为 10 的向量，前 3 个是中心，接着是三个方向向量的长度，最后是方向向量。 更适合从拟合模型直接创建立方体。 addCube(translation, rotation, width, height, depth, id, viewport); 完整的 刚体变换 方式。 translation：中心点位置（Eigen::Vector3f） rotation：旋转（Eigen::Quaternionf） width/height/depth：尺寸 PCL库OBB（体素下采样加速）完整代码示例 #include pcl/io/pcd_io.h#include pcl/point_types.h#include pcl/filters/voxel_grid.h#include pcl/features/moment_of_inertia_estimation.h#include pcl/visualization/pcl_visualizer.h#include Eigen/Dense#include iostreamint main(int argc, char** argv) pcl::PointCloudpcl::PointXYZRGB::Ptr cloud_rgb(new pcl::PointCloudpcl::PointXYZRGB); pcl::PointCloudpcl::PointXYZ::Ptr cloud_xyz(new pcl::PointCloudpcl::PointXYZ); if (argc 2) std::cerr Usage: argv[0] cloud.pcd std::endl; return -1; if (pcl::io::loadPCDFile(argv[1], *cloud_rgb) == -1) PCL_ERROR(Couldnt read file ); return -1; pcl::copyPointCloud(*cloud_rgb, *cloud_xyz); // ===== Step 0: 体素降采样 ===== pcl::PointCloudpcl::PointXYZ::Ptr cloud_filtered(new pcl::PointCloudpcl::PointXYZ); pcl::VoxelGridpcl::PointXYZ vg; vg.setInputCloud(cloud_xyz); vg.setLeafSize(0.01f, 0.01f, 0.01f); // 5mm voxel,根据点云大小调整 vg.filter(*cloud_filtered); // ====== Step 1: OBB 计算 ====== pcl::MomentOfInertiaEstimationpcl::PointXYZ feature_extractor; feature_extractor.setInputCloud(cloud_filtered); feature_extractor.compute(); pcl::PointXYZ min_point_OBB, max_point_OBB, position_OBB; Eigen::Matrix3f rotational_matrix_OBB; feature_extractor.getOBB(min_point_OBB, max_point_OBB, position_OBB, rotational_matrix_OBB); // ====== Step 2: 尺寸和位姿 ====== float length = max_point_OBB.x - min_point_OBB.x; float width = max_point_OBB.y - min_point_OBB.y; float height = max_point_OBB.z - min_point_OBB.z; Eigen::Vector3f position(position_OBB.x, position_OBB.y, position_OBB.z); Eigen::Matrix3f R = rotational_matrix_OBB; std::cout OBB 尺寸: 长= length 宽= width 高= height std::endl; std::cout 旋转矩阵 R: R std::endl; std::cout 平移向量 t: position.transpose() std::endl; // ====== Step 3: 可视化 ====== pcl::visualization::PCLVisualizer::Ptr viewer(new pcl::visualization::PCLVisualizer(OBB Viewer)); viewer-setBackgroundColor(0, 0, 0); viewer-addPointCloudpcl::PointXYZRGB(cloud_rgb, cloud); Eigen::Vector3f pos = position; Eigen::Quaternionf q(R); viewer-addCube(pos, q, length, width, height, OBB); viewer-setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_REPRESENTATION, pcl::visualization::PCL_VISUALIZER_REPRESENTATION_WIREFRAME, OBB); viewer-setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_COLOR, 1.0, 0.0, 0.0, OBB); viewer-addCoordinateSystem(0.1); while (!viewer-wasStopped()) viewer-spinOnce(10); return 0; 基于凸包的最小 OBB 计算（体素降采样加速版）示例 #include pcl/io/pcd_io.h#include pcl/point_types.h#include pcl/visualization/pcl_visualizer.h#include pcl/common/common.h#include pcl/common/transforms.h#include pcl/filters/voxel_grid.h#include pcl/surface/convex_hull.h#include Eigen/Dense#include iostreamint main(int argc, char** argv) if (argc 2) std::cerr Usage: argv[0] cloud.pcd std::endl; return -1; pcl::PointCloudpcl::PointXYZ::Ptr cloud(new pcl::PointCloudpcl::PointXYZ); if (pcl::io::loadPCDFile(argv[1], *cloud) == -1) PCL_ERROR(Couldnt read file ); return -1; // ===== Step 0: 体素降采样 ===== pcl::PointCloudpcl::PointXYZ::Ptr cloud_filtered(new pcl::PointCloudpcl::PointXYZ); pcl::VoxelGridpcl::PointXYZ vg; vg.setInputCloud(cloud); vg.setLeafSize(0.005f, 0.005f, 0.005f); // 5mm voxel,根据点云大小调整 vg.filter(*cloud_filtered); // ===== Step 1: 计算凸包 ===== pcl::ConvexHullpcl::PointXYZ chull; chull.setInputCloud(cloud_filtered); pcl::PointCloudpcl::PointXYZ::Ptr hull(new pcl::PointCloudpcl::PointXYZ); chull.reconstruct(*hull); // ===== Step 2: 枚举凸包三点组合 ===== Eigen::Vector3f best_dims; Eigen::Matrix3f best_rot = Eigen::Matrix3f::Identity(); Eigen::Vector3f best_pos; float min_volume = std::numeric_limitsfloat::max(); for (size_t i = 0; i hull-size(); ++i) for (size_t j = i + 1; j hull-size(); ++j) for (size_t k = j + 1; k hull-size(); ++k) Eigen::Vector3f v1 = hull-points[j].getVector3fMap() - hull-points[i].getVector3fMap(); Eigen::Vector3f v2 = hull-points[k].getVector3fMap() - hull-points[i].getVector3fMap(); Eigen::Vector3f axis1 = v1.normalized(); Eigen::Vector3f axis2 = v2.normalized(); Eigen::Vector3f axis3 = axis1.cross(axis2).normalized(); if (axis3.hasNaN()) continue; axis2 = axis3.cross(axis1); Eigen::Matrix3f R; R.col(0) = axis1; R.col(1) = axis2; R.col(2) = axis3; // 点云旋转到候选方向 Eigen::Matrix4f transform = Eigen::Matrix4f::Identity(); transform.block3, 3(0, 0) = R.transpose(); pcl::PointCloudpcl::PointXYZ rotated; pcl::transformPointCloud(*cloud_filtered, rotated, transform); // 计算包围盒尺寸 pcl::PointXYZ min_pt, max_pt; pcl::getMinMax3D(rotated, min_pt, max_pt); Eigen::Vector3f dims = (max_pt.getVector3fMap() - min_pt.getVector3fMap()); float volume = dims.prod(); if (volume min_volume) min_volume = volume; best_dims = dims; best_rot = R; best_pos = R * ((max_pt.getVector3fMap() + min_pt.getVector3fMap()) * 0.5f); std::cout 最小 OBB 尺寸: best_dims.transpose() std::endl; std::cout 旋转矩阵: best_rot std::endl; std::cout 中心位置: best_pos.transpose() std::endl; // ===== Step 3: 可视化 ===== pcl::visualization::PCLVisualizer::Ptr viewer(new pcl::visualization::PCLVisualizer(Min OBB Viewer)); viewer-setBackgroundColor(0, 0, 0); viewer-addPointCloudpcl::PointXYZ(cloud, cloud); Eigen::Quaternionf q(best_rot); viewer-addCube(best_pos, q, best_dims.x(), best_dims.y(), best_dims.z(), OBB); viewer-setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_REPRESENTATION, pcl::visualization::PCL_VISUALIZER_REPRESENTATION_WIREFRAME, OBB); viewer-setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_COLOR, 1.0, 0.0, 0.0, OBB); while (!viewer-wasStopped()) viewer-spinOnce(10); return 0;","tags":["3D点云"],"categories":["机器视觉"]},{"title":"基于AprilTag标定板的三维重构","path":"/2025/08/22/基于AprilTag标定板的三维重构/","content":"基于AprilTag标定板的三维重构准备工作 深度相机一台 AprilTag标定板 重构物体 深度相机可以用双目相机替代，能进行深度估计即可 AprilTag标定板可以此处生成PDF，然后打印下来 Step1.预先根据AprilTag标定板尺寸，设计每个AprilTag中心的3D坐标 Step2.将物体放置在AprilTag标定板标定板上，确保每个视角都可以看到4个以上的AprilTag Step3.用深度相机拍摄多视角画面，保存为RGB-Depth图片对 Step4.检测RGB图片中AprilTag中心的2D坐标。将它和对应的3D坐标配对。 Step5.根据当前视角下得到的3D-2D坐标点对，进行PnP解算得出相机坐标系关于世界坐标系的旋转平移矩阵 Step6.将所有视角下的拍摄的RGBD图片转换为点云。根据上一步计算出的旋转平移矩阵，将点云变换到世界坐标系下 Step7.合成所有视角的点云，通过体素滤波做下采样 旋转矩阵 R:[[-0.71047329 0.69426789 -0.11497741] [-0.3285593 -0.18276956 0.92663049] [ 0.62231542 0.69612311 0.35796106]]平移向量 t:[[-0.03986195] [ 0.1304609 ] [ 0.37073777]]相机到世界的齐次变换矩阵 T_cw:[[-0.71047329 -0.3285593 0.62231542 -0.21617254] [ 0.69426789 -0.18276956 0.69612311 -0.20655997] [-0.11497741 0.92663049 0.35796106 -0.25818196] [ 0. 0. 0. 1. ]]","tags":["3D点云"],"categories":["机器视觉"]},{"title":"WSL2下复现FoundationPose","path":"/2025/08/21/WSL2下复现FoundationPose/","content":"WSL2下复现FoundationPose1.准备工作下载仓库 git clone https://github.com/NVlabs/FoundationPose.git 下载权重 前往此处下载权重，放在weights/目录下。 下载测试数据集 前往此处下载测试数据，解压到demo_data/目录下。 下载训练数据（可选） 如果要自己train的话，前往此处下载大规模训练数据 下载经过预处理的参考视图（可选） 如果要跑model-free的少样本学习版本， 前往此处下载，解压到demo_data/目录下。 下载YCB-Video数据集(可选) 如果需要YCB-Video数据集，这是一个200G+的数据集，BOP版做了筛选，在100G左右，前往此处下载，解压到demo_data/目录下。 其他细节看这篇：FoundationPose复现及Realsense应用-阿里云开发者社区 2.环境配置安装eigen3sudo apt install libeigen3-dev 安装Conda…… 安装Cuda见另一篇博客**《WSL下配置Cuda》** 创建Conda环境conda create -n foundationpose python=3.9 安装依赖Step1. 把requirements.txt 文件原来的 torch 、torchvision、torchaudio先注释一下，手动安装 pip install torch==2.4.0 torchvision==0.19.0 torchaudio==2.4.0 --index-url https://download.pytorch.org/whl/cu124 Step2. python -m pip install -r requirements.txt Step3. python -m pip install --quiet --no-cache-dir git+https://github.com/NVlabs/nvdiffrast.git 如果下载速度慢或网络卡顿，可以先手动下载到本地后安装 # 下载源码git clone https://github.com/NVlabs/nvdiffrast.git# 进入目录cd nvdiffrast# 用 pip 安装（本地路径）python -m pip install --no-cache-dir . Step4. python -m pip install --quiet --no-cache-dir kaolin==0.16.0 -f https://nvidia-kaolin.s3.us-east-2.amazonaws.com/torch-2.4.0_cu124.html Step5. conda install https://anaconda.org/pytorch3d/pytorch3d/0.7.8/download/linux-64/pytorch3d-0.7.8-py39_cu121_pyt241.tar.bz2 安装PyTorch3D 这里也是安装和pytorch对应的具体看这个PyTorch3D 安装-CSDN博客 ，pytorch3d官网地址install pytorch3d version: pytorch3d Step6. CMAKE_PREFIX_PATH=$CONDA_PREFIX/lib/python3.9/site-packages/pybind11/share/cmake/pybind11 bash build_all_conda.sh 报错： error: #error You need C++17 to compile PyTorcherror: #error C++17 or later compatible compiler is required to use PyTorch. 原因是当前的nvcc编译.cu文件时使用了 -stdc++14, Pytorch C++扩展必须使用C++ 17 或更高版本。解决方法是修改编译参数将C++ 14改为C++ 17。 首先清理之前的构建文件 cd FoundationPose/bundlesdf/mycudarm -rf build *.egg-info 确保 C++17 编译（必须），设置 GPU 架构（可选，但推荐）。修改mycuda下 setup.py c_flags = [-O3, -std=c++17]nvcc_flags = [ -O3, -std=c++17, -U__CUDA_NO_HALF_OPERATORS__, -U__CUDA_NO_HALF_CONVERSIONS__, -U__CUDA_NO_HALF2_OPERATORS__, -gencode, arch=compute_89,code=sm_89 # 针对 RTX 4060] 重新编译 python setup.py build_ext --inplace 或者 pip install -e . --use-pep517 过时警告： easy_install command is deprecatedsetup.py install is deprecatedUnknown distribution option: extra_cflags 当前 PyTorchCUDA 扩展依赖的 setup.py 使用了过时方法。pip 25+ 会对 setup.py develop 出现错误。解决方法是使用 PEP 517518 的方式： pip install -e . --use-pep517 或直接通过 python setup.py build_ext --inplace 编译扩展，而不是 develop。 3.测试Demopython run_demo.py 报错： c++: fatal error: Killed signal terminated program cc1plus 这种情况一般是 编译过程中被系统杀掉了，最常见原因是 内存不足（尤其是 8GB GPU 或内存较小的机器），而不是代码本身的问题。解决方法是降低 CPU 内存占用，或者修改 TORCH_CUDA_ARCH_LIST，避免编译所有架构。 export MAX_JOBS=1\t# 方法1export TORCH_CUDA_ARCH_LIST=8.9 # 方法2 对应你的 RTX 4060 然后运行 python run_demo.py 报错： ImportError: ... libstdc++.so.6: version `GLIBCXX_3.4.32 not found 意思是 系统的 libstdc++ 版本太旧，无法满足 nvdiffrast 插件编译时的要求。这个问题通常发生在 Linux 系统自带的 GCC标准库版本较旧，而 PyTorch 或 nvdiffrast 需要较新的 GLIBCXX。 检查系统当前libstdc++版本，如果没有 GLIBCXX_3.4.32，说明版本过低。 strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX 如果有可能是 Pythonconda 环境没使用到系统的 libstdc++，或者 nvdiffrast 在编译时链接到了一个旧版本的 libstdc++。 确保conda 优先使用系统 libstdc++ export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libstdc++.so.6export LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH 然后直接运行 python run_demo.py 4.自制数据集数据集文件夹格式 .├── mustard0 # 数据集文件夹│ ├── cam_K.txt # 相机内参│ ├── depth # 视频流深度帧│ ├── masks # 第一帧的掩膜│ ├── mesh # 3D模型数据| | ├──texture_map.png # 模型纹理| | ├──textured_simple.obj # 模型文件| | ├──textured_simple.obj.mtl # 模型和纹理的桥梁文件│ ├── rgb # 视频流彩色帧 注意：rgb文件夹下的彩色最好是png，否则要修改读取图片的代码 5.Demo解析import osfrom estimater import * # 引入姿态估计模块（自定义的，封装了 FoundationPose）from datareader import * # 引入数据读取模块import argparse 引入必要模块 if __name__==__main__: parser = argparse.ArgumentParser() code_dir = os.path.dirname(os.path.realpath(__file__)) # 获取当前脚本所在路径 参数解析器，支持从命令行传参 parser.add_argument(--mesh_file, type=str, default=fcode_dir/demo_data/mustard0/mesh/textured_simple.obj)parser.add_argument(--test_scene_dir, type=str, default=fcode_dir/demo_data/mustard0)parser.add_argument(--est_refine_iter, type=int, default=5) # 初始位姿 refinement 迭代次数parser.add_argument(--track_refine_iter, type=int, default=2) # 跟踪 refinement 迭代次数parser.add_argument(--debug, type=int, default=1) # debug 等级parser.add_argument(--debug_dir, type=str, default=fcode_dir/debug)args = parser.parse_args() 定义命令行参数： mesh_file：物体 3D 模型路径 test_scene_dir：测试场景（包含 RGBD 数据）的目录 est_refine_iter：初始估计 refinement 次数 track_refine_iter：跟踪 refinement 次数 debug：调试模式（等级越高保存的中间结果越多） debug_dir：调试文件输出目录 set_logging_format()set_seed(0) 设置日志格式和随机种子，保证实验可复现。 mesh = trimesh.load(args.mesh_file) 加载 3D 网格模型（用 trimesh 库） debug = args.debugdebug_dir = args.debug_diros.system(frm -rf debug_dir/* mkdir -p debug_dir/track_vis debug_dir/ob_in_cam) 清空 debug 文件夹，并新建保存可视化结果的子目录 to_origin, extents = trimesh.bounds.oriented_bounds(mesh)bbox = np.stack([-extents/2, extents/2], axis=0).reshape(2,3) 计算 mesh 的 有向包围盒 (OBB)，得到： to_origin: mesh 对齐到原点的变换矩阵 把 mesh 变换到一个新的坐标系里，在这个坐标系下，物体的 OBB 就是 轴对齐的（盒子中心在原点，边和 XYZ 轴平行）。 举例：如果原来的 mesh 歪着放，to_origin 就是“把它摆正、放到中心”的变换。 extents: 包围盒的长宽高 [lx, ly, lz] bbox: 最终的 3D 包围盒坐标（minmax） 一个最大点和一个最小点确定3D包围盒 scorer = ScorePredictor()refiner = PoseRefinePredictor()glctx = dr.RasterizeCudaContext() 初始化关键组件： ScorePredictor：评分网络（用于评估姿态的好坏）。 PoseRefinePredictor：位姿 refinement 网络。 dr.RasterizeCudaContext()：基于 CUDA 的可微分渲染器（用来渲染和对比 RGBD）。 est = FoundationPose(model_pts=mesh.vertices, model_normals=mesh.vertex_normals, mesh=mesh, scorer=scorer, refiner=refiner, debug_dir=debug_dir, debug=debug, glctx=glctx)logging.info(estimator initialization done) 创建 FoundationPose 实例，传入模型点云、法向量、网格和网络组件。 reader = YcbineoatReader(video_dir=args.test_scene_dir, shorter_side=None, zfar=np.inf) 数据读取器（这里针对 YCB-InEOAT 数据集），返回 RGB、深度、mask 等 for i in range(len(reader.color_files)): logging.info(fi:i) color = reader.get_color(i) depth = reader.get_depth(i) 遍历每一帧，读取 RGB 和深度。 if i==0: mask = reader.get_mask(0).astype(bool) pose = est.register(K=reader.K, rgb=color, depth=depth, ob_mask=mask, iteration=args.est_refine_iter) 在第一帧，调用 register()： 输入相机内参 K、RGB、深度图和物体掩膜，估计物体的初始 6D 姿态。 if debug=3: m = mesh.copy() m.apply_transform(pose) m.export(f{debug_dir}/model_tf.obj) xyz_map = depth2xyzmap(depth, reader.K) valid = depth=0.001 pcd = toOpen3dCloud(xyz_map[valid], color[valid]) o3d.io.write_point_cloud(f{debug_dir}/scene_complete.ply, pcd) 如果 debug≥3： 导出变换后的 mesh。 保存完整的点云（场景点云 + RGB 颜色）。 else: pose = est.track_one(rgb=color, depth=depth, K=reader.K, iteration=args.track_refine_iter) 后续帧调用 track_one()，根据上一帧的结果进行跟踪。 os.makedirs(f{debug_dir}/ob_in_cam, exist_ok=True) np.savetxt(f{debug_dir}/ob_in_cam/{reader.id_strs[i]}.txt, pose.reshape(4,4)) 把每一帧的 4×4 位姿矩阵保存为 txt 文件。、 if debug=1: center_pose = pose@np.linalg.inv(to_origin) vis = draw_posed_3d_box(reader.K, img=color, ob_in_cam=center_pose, bbox=bbox) vis = draw_xyz_axis(color, ob_in_cam=center_pose, scale=0.1, K=reader.K, thickness=3, transparency=0, is_input_rgb=True) cv2.imshow(1, vis[...,::-1]) cv2.waitKey(1) 如果 debug≥1： 将 3D 包围盒投影到图像上。 画出物体坐标系三轴。 用 OpenCV 实时显示结果。 if debug2:os.makedirs(f’{debug_dir}track_vis’, exist_okTrue)imageio.imwrite(f’{debug_dir}track_vis{reader.id_strs[i]}.png’, vis) 如果 debug≥2：保存跟踪可视化结果到 track_vis 文件夹。","tags":["6D-Pose"],"categories":["项目复现"]},{"title":"WSL2下配置Cuda","path":"/2025/08/21/WSL2下配置Cuda/","content":"WSL2下配置Cuda点击此处打开Cuda下载官网，选择目标平台，按步骤输入安装指令。 如果出现缺失libtinfo5依赖 ，可能是因为WSL2是Ubuntu24.04只有 libtinfo6，需要手动安装。 安装来自 Ubuntu 安全（security）仓库 的兼容版本 libtinfo5_6.3-2ubuntu0.1。 sudo apt updatewget http://security.ubuntu.com/ubuntu/pool/universe/n/ncurses/libtinfo5_6.3-2ubuntu0.1_amd64.debsudo apt install ./libtinfo5_6.3-2ubuntu0.1_amd64.deb 重新执行Cuda最后一步的安装指令，安装成功。接下来将Cuda加入环境变量。 打开环境变量文件 vim ~/.bashrc 加入Cuda配置 export PATH=/usr/local/cuda/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH 保存文件然后刷新环境变量 source ~/.bashrc 命令行输入 nvcc -V 输出版本信息则视为成功 nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2024 NVIDIA CorporationBuilt on Thu_Mar_28_02:18:24_PDT_2024Cuda compilation tools, release 12.4, V12.4.131Build cuda_12.4.r12.4/compiler.34097967_0","tags":["Linux"],"categories":["系统配置与运维"]},{"title":"手眼标定理论与实践","path":"/2025/06/24/手眼标定理论与实践/","content":"手眼标定1.术语解释$R^{base}_{end}$: 机械臂末端坐标系到基底坐标系的旋转变换矩阵，对应cv2.calibrateHandEye()参数R_gripper2base $T^{base}_{end}$: 机械臂末端坐标系到基底坐标系的平移变换矩，对应cv2.calibrateHandEye()参数t_gripper2base $R^{cam}_{target}$: 标定板坐标系到相机坐标系的旋转变换矩阵，对应cv2.calibrateHandEye()参数R_target2cam $T^{cam}_{target}$: 标定板坐标系到相机坐标系的平移变换矩阵，对应cv2.calibrateHandEye()参数R_target2cam 对一般机械臂，对于每个位姿，通常会返回六个参数：$\\theta_x、\\theta_y、\\theta_z、t_x、t_y、t_z$，这六个参数是机械臂末端在基地坐标系下的位姿的表示。$$R^{base}_{end}R_zR_yR_x$$ $$T^{base}_{end}(t_x,t_y,t_z)^T$$ 变换矩阵：$$M^A_B\\left[\\begin{matrix}R^A_B T^A_B \\\\ 0 1\\end{matrix}\\right]$$ $$M^A_B {M^B_A}^{-1}$$ 转换关系$$R_{base}^{end}{R^{base}_{end}}^{-1}$$ $$M_{base}^{end}{M^{base}_{end}}^{-1}$$ $$T_{base}^{end} -{R_{end}^{base}}^{-1}T_{end}^{base}$$ 注意：由于R是正交矩阵，正交矩阵的逆等于正交矩阵的转置，所以有时候也会写为$R_{base}^{end}{R^{base}_{end}}^T$，但是变换矩阵M不是正交，不可以用转置表示逆 代码： # 求逆R_b2g = R_g2b.T # 旋转矩阵逆就是转置t_b2g = - R_g2b.T @ t_g2b $$R_x(\\theta_x)\\left[ \\begin{matrix} 1 0 0 \\\\ 0 cos\\theta_x -sin\\theta_x \\\\ 0 sin\\theta_x cos\\theta_x \\end{matrix}\\right]$$ $$R_y(\\theta_x)\\left[ \\begin{matrix} cos\\theta_y 0 sin\\theta_y \\\\ 0 1 0 \\\\ -sin\\theta_x 0 cos\\theta_y \\end{matrix}\\right]$$ $$R_z(\\theta_x)\\left[ \\begin{matrix} cos\\theta_z -sin\\theta_z 0 \\\\ sin\\theta_z cos\\theta_z 0 \\\\ 0 0 1 \\end{matrix}\\right]$$ 通过拍摄标定板，使用cv2.solvePnp()函数，可以求得 $R^{cam}_{target}$ $T^{cam}_{target}$ 2.眼在手外 求解目标：基底坐标系到相机坐标系的变换矩阵$M^{cam}_{base}$ 实现方法： 标定板固定在机械臂末端 使用相机拍摄机械臂不同姿态下的标定板图片n张（n3） 则对于每张图片可知：$$M^{cam}{base}M^{cam}{target}*M^{target}{end}*M^{end}{base}$$c: 相机坐标系下的坐标 b: 基底坐标系下的坐标$$cM^{cam}_{base}*b$$ $$b {M^{cam}_{base}}^{-1}*c$$ 其中： $M^{cam}_{target}$: 可通过拍摄标定板图片直接求解 $M^{end}_{base}$: 可由机械臂末端位姿参数求得 $M^{target}_{end}$: 未知量，由于标定板固定在机械臂末端，所以对每组图片，该转换矩阵都相同 变形得： $$ M^{target}_{end}={M^{cam}_{target}}^{-1}*M^{cam}_{base}*{M^{end}_{base}}^{-1} $$ 当我们拍摄了2张图片后： $$ {M^{cam}_{target}}^{-1}_1*M^{cam}_{base}*{M^{end}_{base}}^{-1}_1 = {M^{cam}_{target}}^{-1}_2*M^{cam}_{base}*{M^{end}_{base}}^{-1}_2 $$ 变形得： $$ {M^{cam}_{target}}_2*{M^{cam}_{target}}^{-1}_1*M^{cam}_{base} = M^{cam}_{base}*{M^{end}_{base}}^{-1}_2*{M^{end}_{base}}_1 $$ 这是一个$AXXA$的方程 当我们拍摄了n张图片后，我们就有了n-1个方程的方程组 通过Tais方法解方程 3.眼在手上4.踩坑记录1.标定板单位和机械臂坐标单位对齐 2.关闭相机镜像 3.不同分辨率下的标定数据不能通用","tags":["OpenCV"],"categories":["机器视觉"]},{"title":"相机成像模型与相机标定","path":"/2025/06/23/相机成像模型与相机标定/","content":"小孔成像由于相机采用小孔成像的原理来采集图像，为了使图像更清晰，就采用了透镜的方式。但是因为透镜本身在成像过程中会不可避免的引入径向畸变和切向畸变（比如一条直线成像后会变成一条弧线）。为了使得现实中的图像能够真实的呈现在图片中有利于之后的机械臂的抓取，则需要对相机进行畸变校正。 相机的成像模型 世界坐标系是一个物体在真实三维世界下的坐标，世界坐标系的原点根据具体情况来定 相机坐标系是以相机光心为原点的三维坐标系，Zc为深度信息 图像坐标系是以图像中心为原点的二维坐标系，P点为Pw投影到像平面上的位置 像素坐标系是以图像左上角为原点的二维坐标系，好处是所有坐标都是正数 相机成像过程为，世界坐标系经过刚体变换（平移、旋转）后和相机坐标系重叠，即转换为相机坐标系。然后通过透视投影转换为图像坐标，最后经过坐标变换得出像素坐标。 世界坐标系到相机坐标系从世界坐标系变换到相机坐标系属于刚体变换:即物体不会发生形变，只需要进行旋转和平移。思路:先进行坐标系旋转，后进行坐标系平移。 世界坐标系通过左乘矩阵$R_z$先绕Z轴转动$\\theta$角，再通过左乘矩阵$R_y$绕Y轴转动$\\beta$角,最后通过左乘矩阵$R_x$绕X轴转动$\\alpha$角。于是可以得到旋转矩阵$RR_xR_yR_z$。 经过一系列的旋转，世界坐标系和相机坐标系的朝向一致，经过平移可以让两个坐标系重合。平移向量为世界坐标系原点减去相机坐标系原点。将平移和旋转叠加起来得到下式： 相机坐标系到图像坐标系透视投影(perspective projection): 用中心投影法将形体投射到投影面上，从而获得的一种较为接近视觉效果的单面投影图，有一点像皮影戏它符合人们心理习惯，即离视点近的物体大，离视点远的物体小。 根据相似三角形原理可得： 图像坐标系到像素坐标系 理想相机数学模型 相机畸变畸变分为桶形畸变和枕形畸变。 另外在相机装配过程中成像芯片可能和镜头不平行，最后图像可能发生倾斜畸变 畸变模型 两种畸变公式叠加起来得到最后的畸变公式 模型总结 张正友标定法现在对于相机最常用的方法是张正友标定法，这种方法是利用棋盘格标定板每个角点像素坐标的相对关系以及在已知的真实坐标相对关系的条件下计算出来的。在opencv中已经有了相对于的库，在使用之前需要设置一下每个格子的大小以及格子的行列数（减去1）即可进行相机标定。 用二维靶标代替三维标靶 用棋盘格的角点作为特征点 张正友标定只考虑了径向畸变，没有考虑切向畸变 标定步骤 打印标定板 - 从不同角度拍摄 - 提取特征点 - 估计无畸变情况下的五个内参和六个外参 - 估计畸变参数 - 最大似然法进行联合优化 - 相机内参、外参、畸变参数 标定图像的选择 常见的标定图案有棋盘格、圆、圆环，对于普通相机一般使用棋盘格就可以了 标定板注意事项 棋盘格的大小要合适，不能太小也不能太大，保证标定板的成像面积大致占整个画面的14 棋盘格内角点行列个数最好不一致，比如7*8 须保证打印的棋盘格的平整性，尽可能贴平 参数个数 总参数个数: 5个相机内参(也有说4个的)，3个旋转角度、3个平移，5个畸变参数 相机内参: f,dx,dy,u0,v0(fx,fy)，旋转:(α,Ψ,@)，平移:tx,ty,tz，畸变(kl,k2,k3,pl,p2) 不同的棋盘格图像，外参是不同的，一般外参指的是第一张图像的旋转平移参数 拍摄注意事项 把图像分成四个象限，标定板平均分布在每个象限，每个象限至少拍两个不同倾斜角度的图片 标定板图片需要覆盖整个测量视场，标定图片的数量通常在15~25张之间 标定板的成像面积应大致占整幅画面的13~14 标定板成像过暗就需要用辅助光源补光，过亮就调整曝光时间，保证标定板的亮度足够且均匀 标定过程，相机的光圈、焦距不能发生改变改变需要重新标定 重投影误差 标定后每个三维点根据相机的投影矩阵计算得到的图像位置与实际图像位置之间总存在一个距离，这个距离的累加和就是重投影误差一般情况下如果重投影误差小于0.3pixel，我们就认为标定效果良好。","tags":["OpenCV"],"categories":["机器视觉"]},{"title":"OpenCV多尺度模板匹配","path":"/2025/06/04/OpenCV多尺度模板匹配/","content":"import cv2import numpy as np# 加载原图和模板图（灰度图）img = cv2.imread(image.jpg, 0)template = cv2.imread(template.jpg, 0)img_color = cv2.cvtColor(img.copy(), cv2.COLOR_GRAY2BGR) # 转为彩色图，便于画彩色矩形# 获取模板原始大小t_height, t_width = template.shape[:2]# 设置尺度范围scale_factors = [0.5, 0.75, 1.0, 1.25, 1.5]# 设置匹配的阈值（相似度越接近1越相似）threshold = 0.8# 遍历不同的缩放比例for scale in scale_factors: # 缩放模板 resized_template = cv2.resize(template, None, fx=scale, fy=scale, interpolation=cv2.INTER_LINEAR) rt_height, rt_width = resized_template.shape[:2] # 如果模板大于原图，则跳过 if rt_height img.shape[0] or rt_width img.shape[1]: continue # 进行模板匹配 result = cv2.matchTemplate(img, resized_template, cv2.TM_CCOEFF_NORMED) # 找到所有匹配得分大于阈值的位置 y_coords, x_coords = np.where(result = threshold) # 遍历每一个符合条件的位置 for (x, y) in zip(x_coords, y_coords): top_left = (x, y) bottom_right = (x + rt_width, y + rt_height) # 在图像上画出绿色矩形框表示匹配区域 cv2.rectangle(img_color, top_left, bottom_right, (0, 255, 0), 2) # 显示匹配得分（可选） score = result[y, x] print(fScale: scale:.2f, Match Score: score:.4f, Position: top_left)# 显示最终结果cv2.imshow(Multi-match Template Matching, img_color)cv2.waitKey(0)cv2.destroyAllWindows()","tags":["OpenCV"],"categories":["机器视觉"]},{"title":"OpenCV图像降噪","path":"/2025/06/04/OpenCV图像降噪/","content":"OpenCV 提供了多种降噪方法，可以根据具体的需求选择合适的方法。常用的图像降噪方法包括： 高斯滤波（Gaussian Blur）：利用高斯函数对图像进行模糊处理，去除噪声。 import cv2# 读取图像image = cv2.imread(input_image.jpg)# 高斯滤波denoised_image = cv2.GaussianBlur(image, (5, 5), 0)cv2.imshow(Denoised Image, denoised_image)cv2.waitKey(0)cv2.destroyAllWindows() 中值滤波（Median Blur）：用像素邻域的中值来代替像素值，适用于去除椒盐噪声。 import cv2# 读取图像image = cv2.imread(input_image.jpg)# 中值滤波denoised_image = cv2.medianBlur(image, 5)cv2.imshow(Denoised Image, denoised_image)cv2.waitKey(0)cv2.destroyAllWindows() 双边滤波（Bilateral Filter）：保留边缘的同时进行降噪处理，适合保留图像细节。 import cv2# 读取图像image = cv2.imread(input_image.jpg)# 双边滤波denoised_image = cv2.bilateralFilter(image, 9, 75, 75)cv2.imshow(Denoised Image, denoised_image)cv2.waitKey(0)cv2.destroyAllWindows()","tags":["OpenCV"],"categories":["机器视觉"]},{"title":"OpenCV轮廓提取和连通域计算","path":"/2025/06/04/OpenCV轮廓提取和连通域计算/","content":"轮廓检测 (Contour Detection)1.基本轮廓检测import cv2import numpy as np# 读取图像并转为灰度图img = cv2.imread(image.jpg)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 二值化处理ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)# 查找轮廓contours, hierarchy = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)# 绘制轮廓result = img.copy()cv2.drawContours(result, contours, -1, (0, 255, 0), 2) 2.轮廓检索模式 cv2.RETR_EXTERNAL: 只检索外部轮廓 cv2.RETR_LIST: 检索所有轮廓，不建立层级关系 cv2.RETR_CCOMP: 检索所有轮廓，建立两级层级关系 cv2.RETR_TREE: 检索所有轮廓，建立完整层级关系 3.轮廓近似方法 cv2.CHAIN_APPROX_NONE: 存储所有轮廓点 cv2.CHAIN_APPROX_SIMPLE: 压缩水平、垂直和对角线段，只保留端点 4.轮廓属性计算for contour in contours: # 轮廓面积 area = cv2.contourArea(contour) # 轮廓周长 perimeter = cv2.arcLength(contour, True) # 边界矩形 x, y, w, h = cv2.boundingRect(contour) # 最小外接圆 (cx, cy), radius = cv2.minEnclosingCircle(contour) # 轮廓重心 M = cv2.moments(contour) if M[m00] != 0: cx = int(M[m10] / M[m00]) cy = int(M[m01] / M[m00]) 连通域计算 (Connected Components)1.基本连通域分析# 使用cv2.connectedComponentsnum_labels, labels = cv2.connectedComponents(binary)# 创建彩色标签图像label_img = np.uint8(255 * labels / np.max(labels))colored_labels = cv2.applyColorMap(label_img, cv2.COLORMAP_JET) 2.带统计信息的连通域分析# 使用cv2.connectedComponentsWithStatsnum_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(binary)# stats包含每个连通域的统计信息：# [x, y, width, height, area]for i in range(1, num_labels): # 跳过背景(label=0) x, y, w, h, area = stats[i] cx, cy = centroids[i] print(f连通域 i: 面积=area, 中心=(cx:.1f, cy:.1f)) # 在图像上标记 cv2.rectangle(result, (x, y), (x+w, y+h), (255, 0, 0), 2) cv2.circle(result, (int(cx), int(cy)), 3, (0, 0, 255), -1) 3.连通域过滤# 根据面积过滤小连通域min_area = 100filtered_labels = labels.copy()for i in range(1, num_labels): if stats[i, cv2.CC_STAT_AREA] min_area: filtered_labels[filtered_labels == i] = 0# 重新标记过滤后的连通域filtered_binary = (filtered_labels 0).astype(np.uint8) * 255 4.保存所有连通域num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(g_cam, connectivity=8)output_image = np.zeros_like(g_cam)for i in range(1, num_labels): output_image[labels == i] = 255 5.单独保存连通域for label in range(1, num_labels): ################# # 单个连通域 ################# component_image = np.zeros_like(labels) component_image[labels == label] = 255 component_image = np.uint8(component_image)","tags":["OpenCV"],"categories":["机器视觉"]},{"title":"自动划分数据集脚本","path":"/2025/05/19/自动划分数据集脚本/","content":"自动将数据集划分为测试集、验证集、测试集（1 - train - val） 文件夹格式： source_dir/||-- class1/| |-- 1.png| |-- 2.png| |-- ...| ||-- class2/| |-- 1.png| |-- 2.png| |-- ...||-- class3/| |-- 1.png| |-- 2.png| |-- ...|-- ... 脚本： import os # 操作文件和文件夹路径import random # 用于打乱文件顺序import shutil # 用于复制文件def split_dataset(source_dir, dest_dir, train_ratio=0.8, val_ratio=0.1): 按指定比例划分图像数据集为训练集、验证集和测试集。 参数： source_dir: 原始数据集路径，要求每个类别是一个子文件夹 dest_dir: 输出路径，将创建 train/val/test 子目录 train_ratio: 训练集所占比例（默认0.8） val_ratio: 验证集所占比例（默认0.1），测试集 = 1 - train - val # 获取所有类别名称（即 source_dir 下的子文件夹） class_names = os.listdir(source_dir) for class_name in class_names: # 获取每个类别下的所有文件路径（例如图片） files = os.listdir(os.path.join(source_dir, class_name)) # 打乱文件顺序，确保划分是随机的 random.shuffle(files) # 计算训练集和验证集的分界点 train_split = int(len(files) * train_ratio) val_split = int(len(files) * (train_ratio + val_ratio)) # 划分文件列表 subsets = train: files[:train_split], # 前 train_ratio 的文件 val: files[train_split:val_split], # 中间 val_ratio 的文件 test: files[val_split:] # 剩下的作为测试集 # 复制文件到对应的目标路径 for subset, subset_files in subsets.items(): # 构建目标子文件夹路径，如：dest_dir/train/class_name/ subset_dir = os.path.join(dest_dir, subset, class_name) # 创建子文件夹（如果不存在） os.makedirs(subset_dir, exist_ok=True) for f in subset_files: # 构建原始文件路径和目标路径 src_path = os.path.join(source_dir, class_name, f) dst_path = os.path.join(subset_dir, f) # 复制文件 shutil.copy(src_path, dst_path)# 示例调用：# split_dataset(data/original, data/split)# 假设 data/original 中是按类别分文件夹的结构，调用后将在 data/split 下创建 train/val/test 三个子文件夹，每个内部保留类别结构。","tags":["数据集"],"categories":["数据处理"]},{"title":"日志/终端/代码中通用的 Unicode Emoji 字符","path":"/2025/05/18/日志-终端-代码中通用的 Unicode Emoji 字符/","content":"在代码日志（如终端输出、构建日志、CICD 脚本、Git 提交、调试信息）中使用 Emoji 表情符号，可以增强可读性和快速识别不同类型的信息。 ✅ 成功完成 Emoji 含义 Unicode ✅ 操作成功 U+2705 ✔️ 已完成通过检查 U+2714 U+FE0F 🟢 状态良好已启用 U+1F7E2 🎉 成功构建完成 U+1F389 🆗 OK状态正常 U+1F197 ⚠️ 警告注意 Emoji 含义 Unicode ⚠️ 警告 U+26A0 U+FE0F 🟡 中性需要注意 U+1F7E1 ❕ 轻微警告提示 U+2755 🔅 降低等级可选优化 U+1F505 ❌ 错误失败 Emoji 含义 Unicode ❌ 错误失败 U+274C ❗ 严重错误阻塞 U+2757 🔴 严重崩溃 U+1F534 💥 崩溃异常 U+1F4A5 🛑 停止 U+1F6D1 🔄 构建处理过程 Emoji 含义 Unicode 🔄 正在处理刷新 U+1F501 ⏳ 等待中 U+23F3 🕐 等待超时提醒 U+1F550 📦 构建中包管理 U+1F4E6 🧪 测试调试 Emoji 含义 Unicode 🧪 单元测试 U+1F9EA 🐞 Bug调试中 U+1F41E 🔍 日志搜索跟踪 U+1F50D 🧹 清理清除缓存 U+1F9F9 📄 文件Git 操作 Emoji 含义 Unicode 📄 文件变更 U+1F4C4 📝 文档更新 U+1F4DD 🗃️ 数据结构配置更改 U+1F5C3 U+FE0F 🧱 构建模块 U+1F9F1 🧠 信息调试输出 Emoji 含义 Unicode ℹ️ 信息 U+2139 U+FE0F 🧠 思路逻辑提示 U+1F9E0 🗒️ 输出日志文本 U+1F5D2 U+FE0F 📊 分析结果 U+1F4CA 🌐 网络部署服务 Emoji 含义 Unicode 🚀 启动部署 U+1F680 🌐 网络相关 U+1F310 🛰️ 后端通信 U+1F6F0 U+FE0F 🛠️ 配置中维护 U+1F6E0 U+FE0F 示例代码日志输出✅ 构建成功⚠️ 警告：某些依赖版本过旧❌ 测试失败：test_login_case_3🚀 部署完成：v2.3.0🔍 日志分析开始...","tags":["美化"],"categories":["通用开发技巧"]},{"title":"Labelme检测标注转Yolo格式","path":"/2025/05/18/Labelme检测标注转Yolo格式/","content":"labelme标注图片标签为json格式： version: 5.2.1, flags: , shapes: [ label: ng, points: [ [ 663.9770114942528, 393.28735632183907 ], [ 691.5632183908044, 431.2183908045977 ] ], group_id: null, description: , shape_type: rectangle, flags: ], imagePath: 1.png, imageData: xxxxxxxxxxxxxxxxxxxxxx imageHeight: 1536, imageWidth: 1536 Yolo格式的图片标签格式为txt： 每行：class_id x_center y_center width height 0 0.441257 0.268394 0.017960 0.024695 LabelMe（rectangle）转 YOLO 格式脚本import osimport jsonfrom tqdm import tqdm# 自定义类别列表，顺序对应 class_id（请根据你的数据修改）CLASS_LIST = [ng]def convert_labelme_rect_to_yolo(json_path, output_dir): 将LabelMe标注的矩形框转换为YOLO格式。 Args: json_path (str): LabelMe标注文件的路径。 output_dir (str): 输出YOLO格式文件的目录。 Returns: None Raises: FileNotFoundError: 如果指定的LabelMe标注文件不存在。 JSONDecodeError: 如果JSON文件解析失败。 KeyError: 如果JSON文件中缺少必要的键。 with open(json_path, r) as f: data = json.load(f) image_width = data[imageWidth] image_height = data[imageHeight] image_name = os.path.splitext(data[imagePath])[0] yolo_lines = [] for shape in data[shapes]: if shape[shape_type] != rectangle: continue # 跳过非矩形 label = shape[label] if label not in CLASS_LIST: continue # 跳过不在类别列表中的标签 class_id = CLASS_LIST.index(label) (x1, y1), (x2, y2) = shape[points] # 计算归一化后的中心坐标和宽高 x_center = ((x1 + x2) / 2) / image_width y_center = ((y1 + y2) / 2) / image_height bbox_width = abs(x2 - x1) / image_width bbox_height = abs(y2 - y1) / image_height yolo_line = fclass_id x_center:.6f y_center:.6f bbox_width:.6f bbox_height:.6f yolo_lines.append(yolo_line) # 写入 .txt 文件 os.makedirs(output_dir, exist_ok=True) output_path = os.path.join(output_dir, image_name + .txt) with open(output_path, w) as f: f.write( .join(yolo_lines)) print(f✅ Converted: json_path - output_path)def convert_all_jsons(input_dir, output_dir): 将指定目录下的所有JSON文件转换为YOLO格式并保存到输出目录。 Args: input_dir (str): 输入目录路径，该目录下应包含多个JSON文件。 output_dir (str): 输出目录路径，转换后的YOLO格式文件将保存在此目录下。 Returns: None Raises: FileNotFoundError: 如果输入目录不存在，则抛出此异常。 NotADirectoryError: 如果输入路径不是一个目录，则抛出此异常。 os.makedirs(output_dir, exist_ok=True) for file in tqdm(os.listdir(input_dir)): if file.endswith(.json): convert_labelme_rect_to_yolo(os.path.join(input_dir, file), output_dir)# 使用示例if __name__ == __main__: input_folder = ./json # 替换为你的LabelMe JSON文件夹路径 output_folder = ./label # 输出YOLO标注文件夹 convert_all_jsons(input_folder, output_folder) 每个 JSON 会生成一个 .txt 文件，与图片同名。 所有值都已归一化到 [0, 1]。","tags":["标注","Yolo"],"categories":["数据处理"]},{"title":"Pandas缺失数据处理","path":"/2025/05/14/Pandas缺失数据处理/","content":"缺失值与空值**缺省值：**数据集中数值为空的值, pandas使用Nan NaT 表示 **空值：**空字符串 s1 = [10, 10.5, None, 11]s2 = [7, 6.9,7.5,None]pdata = pd.DataFrame(s1:s1, s2:s2)pdata s1 s2 0 10.0 7.0 1 10.5 6.9 2 NaN 7.5 3 11.0 NaN 缺失值判断判断方法： pd.isnull()：缺省值对应的值为True，返回值为Boolean的Series或者DataFrame对象 pd.notnull()：缺省值对应的值为False，返回值为Boolean的Series或者DataFrame对象 pdata.isnull() pdata.notnull() ：同上 sdata = pd.Series([1,2,3, np.NaN])pd.isnull(sdata) 输出： 0 False1 False2 False3 Truedtype: bool s1 = [10, 10.5, None, 11]s2 = [7, 6.9,7.5,None]pdata = pd.DataFrame(s1:s1, s2:s2)pd.isnull(pdata) s1 s2 0 False False 1 False False 2 True False 3 False True 判断是否有缺失值方式1：np.all 与 pd.notnull结合 s1 = [10, 10.5, None, 11]s2 = [7, 6.9,7.5,None]pdata = pd.DataFrame(s1:s1, s2:s2)# pd.notnull,若包含缺省值，缺省值对应值为False# np.all：若对象中包含假，返回False， 否则返回真np.all(pd.notnull(pdata))# 返回False， 说明包含缺省值，否则不包含缺省值 输出： False s1 = [10, 10.5, 11]s2 = [7, 6.9,7.5]pdata = pd.DataFrame(s1:s1, s2:s2)np.all(pd.notnull(pdata)) 输出： True 方式2：np.any 与 pd.isnull结合 s1 = [10, 10.5, 11]s2 = [7, 6.9,7.5]pdata = pd.DataFrame(s1:s1, s2:s2)# isnull：缺省值对应值为True# any:对象中包含真，返回Truenp.any(pd.isnull(pdata))# 返回False,说明不含缺省值，返回True说明包括缺省值 输出： False 缺省值处理方式缺省值处理： 过滤缺省值(按行列) 删除缺省值(按行列) 填充值，填充值方式： 插入均值，中位数,最大值，最小值等 插入特殊值 插入前(后)值入前(后)值 缺省值过滤举例：某两只股票1周收盘值，None表示当前停盘 需求：获取两只股票都没有停牌的数据 # 数据：某两只股票1周收盘值，None表示当前停盘s1 = [10, 10.5, None, 11]s2 = [7, 6.9,7.5,None]pdata = pd.DataFrame(s1:s1, s2:s2)pdata s1 s2 0 10.0 7.0 1 10.5 6.9 2 NaN 7.5 3 11.0 NaN # 需求：获取两只股票都没有停牌的数据# 获取boolean索引bindex = np.all(pdata.notnull(), axis=1)bindex 输出： 0 True1 True2 False3 Falsedtype: bool # 获取没有停牌数据pdata[bindex] s1 s2 0 10.0 7.0 1 10.5 6.9 删除缺省值pdata.dropna(axis=0, how=any, thresh=None, subset=None, inplace=False) 主要参数： 参数 说明 axis 0 或 ‘index’：按行操作，1 或 ‘columns’：按列操作 how 根据 axis 指定操作方式，any：只要有一个 Na 就删除，all：全部为 Na 才删除 thresh 指定非 Na 值的数量，非 Na 数量大于等于 thresh 时不删除 subset 指定操作的列子集 inplace True：在原始数据中进行修改 准备数据： s1 = [10, 10.5, None, 11]s2 = [7, 6.9,7.5,None]s3 = [7, 6.9,7.5,7]s4 = [None, 6.9,None,7.2]pdata = pd.DataFrame(s1:s1, s2:s2, s3:s3,s4:s4)pdata s1 s2 s3 s4 0 10.0 7.0 7.0 NaN 1 10.5 6.9 6.9 6.9 2 NaN 7.5 7.5 NaN 3 11.0 NaN 7.0 7.2 需求： 删除包含缺省值的行 删除包含2个缺省值行 删除指定列包含缺省值 删除包含缺省值的列 # 删除包含缺省值行pdata.dropna() s1 s2 s3 s4 1 10.5 6.9 6.9 6.9 # 缺省值数量大于1，thresh设置为3# thresh:指定非Na数量(非Na数量=thresh，不删除)pdata.dropna(thresh=3) s1 s2 s3 s4 0 10.0 7.0 7.0 NaN 1 10.5 6.9 6.9 6.9 3 11.0 NaN 7.0 7.2 # 指定列：[s1,s4]pdata.dropna(subset=[s1,s4]) s3 0 7.0 1 6.9 2 7.5 3 7.0 注意： 以上数据删除都不对原始数据进行修改 指定inplace为True，在原始数据中进行修改 缺失值填充填充方法： pdata.fillna(value=None, method=None, axis=None, inplace=False, limit=None, downcast=None, **kwargs) 参数 说明 value 填充值 method 填充方式：{backfill, bfill, pad, ffill, None} axis 指定行列：0 或 index 表示按行，1 或 columns 表示按列 limit 插入数量限制 pdata s1 s2 s3 s4 0 10.0 7.0 7.0 NaN 1 10.5 6.9 6.9 6.9 2 NaN 7.5 7.5 NaN 3 11.0 NaN 7.0 7.2 需求： 缺省值填充固定值0 使用前后面数据填充 使用均值填充 插入均值插入均值 # 固定值0pdata.fillna(0) s1 s2 s3 s4 0 10.0 7.0 7.0 0.0 1 10.5 6.9 6.9 6.9 2 0.0 7.5 7.5 0.0 3 11.0 0.0 7.0 7.2 # 使用前一行数据填充pdata.fillna(method=ffill)# 使用向前填充 (ffill) 替代 fillnapdata.ffill() # 使用后一行数据填充pdata.fillna(method=bfill)# 使用向后填充 (bfill) 替代 fillnapdata.bfill() # 使用后一列数据填充pdata.fillna(axis=1,method=bfill)# 使用向后填充 (bfill) 替代 fillnapdata.bfill(axis=1) 对于股票缺省值，我们倾向于，使用前一天数据填充缺失值 插入均值，中位数，最大值，最小值pdata.mean/max/min/median(axis=None, skipna=None, level=None, numeric_only=None, **kwargs) 主要参数： 参数 说明 axis 方向，0 表示按列，1 表示按行 skipna 是否忽略 NaN，True 表示不计算 NaN，默认为 True #插入均值pdata.fillna(pdata.mean()) #插入中位数pdata.fillna(pdata.median())","tags":["Pandas"],"categories":["数据处理"]},{"title":"Pandas数据导入与保存","path":"/2025/05/14/Pandas数据导入与保存/","content":"目的： 数据导入：excel, csv文件 数据导出 基本统计 缺省数据处理 数据导入数据是分析基础，实际工作中，数据来自于企业内部数据，网络数据，开源数据集； 方法 说明 pd.read_csv(filepath_or_buffer, sep=,, delimiter=None, header=infer, names=None, index_col=None, ...) 读取CSV文件 pd.read_excel(io, sheet_name=0, names=None, index_col=None, usecols=None, ...) 读取Excel文件 pd.read_json(path_or_buf=None, orient=None, typ=frame, dtype=None, ...) 读取JSON文件 读取excel文件 import pandas as pdimport numpy as np# 读取excel文件fpath = rdata\\test.xlsxpdata = pd.read_excel(fpath)pdata 读取csv文件 # 读取csv文件fpath = rdata\\GDP.csvpdata = pd.read_csv(fpath, encoding=gbk)pdata 导入csv指定列 # 导入指定列fpath = rdata\\GDP.csvpdata = pd.read_csv(fpath,usecols = [Country Name,1990], encoding=gbk)pdata 导入csv指定表头 # 导入指定表头fpath = rdata\\GDP.csvpdata = pd.read_csv(fpath,header=1, encoding=gbk)pdata csv无表头指定None # 无表头指定Nonepdata = pd.read_csv(fpath,header=None, encoding=gbk)pdata 数据保存# 保存文件import pandas as pdimport numpy as np# 读取excel文件fpath = rdata\\GDP.csvcsv_path1 = rdata ew_GDP_1.csvcsv_path2 = rdata ew_GDP_2.csvcsv_path3 = rdata ew_GDP_3.csvpdata = pd.read_csv(fpath, encoding=gbk)# 保存格式带索引pdata.to_csv(csv_path1)# 保存格式不带索引pdata.to_csv(csv_path2, index=False)# 保存格式不带索引,保存指定列pdata.to_csv(csv_path3, index=False, columns=[1990,1991])","tags":["Pandas"],"categories":["数据处理"]},{"title":"Anaconda备忘录","path":"/2025/05/08/Anaconda备忘录/","content":"镜像源设置在命令行中临时设置： pip install some-package -i https://pypi.tuna.tsinghua.edu.cn/simple 使用conda环境中的pip命令前激活镜像源环境变量： export PIP_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simplepip install some-package 虚拟环境创建： conda create -n xxx python=xxx 删除： conda env remove -n xxx 环境配置高级系统设置-环境变量-系统变量-Path D:\\Tools\\anaconda3D:\\Tools\\anaconda3\\ScriptsD:\\Tools\\anaconda3\\Library\\bin Linux下代理设置export http_proxy=http://172.23.16.1:7897export https_proxy=http://172.23.16.1:7897 git代理-c http.proxy=http://127.0.0.1:7897","tags":["Anaconda"],"categories":["开发工具与版本控制"]},{"title":"Pandas基础——DataFrame数据结构","path":"/2025/05/08/Pandas基础——DataFrame数据结构/","content":"DataFrame: 多种类型的列构成的二维标签数据结构(多列) DataFrame类: pd.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) 参数： data: 一维数据，二维数据index: 行标签columns: 列标签 1. Dataframe创建一行一列 # 一维数pd.DataFrame(data=np.arange(1,4)) 0 0 1 1 2 2 3 多列 # 多维数据 data为4X4data = np.arange(16).reshape(4,4)pd.DataFrame(data=data) 0 1 2 3 0 0 1 2 3 1 4 5 6 7 2 8 9 10 11 3 12 13 14 15 设置index与columns # 设置index与columnsdata = np.arange(16).reshape(4,4)pdata = pd.DataFrame(data=data, index=list(abcd), columns=[c1,c2,c3,c4])pdata # 设置index与columnsdata = c1:[1,2,3], c2:[4,5,6]pdata = pd.DataFrame(data=data)pdata 设置列标签 # 设置列标签pdata.columns = [t1,t2]pdata 2. DataFrame对象访问获取指定列 # 获取一列数据，返回Series对象pdata[c1] 输出： 0 11 22 3Name: c1, dtype: int64 # 取多列数据pdata[[c1,c2]] 输出： c1 c2 0 1 4 1 2 5 2 3 6 loc操作 loc操作：使用类似列表方式去对数据进行访问，支持bool索引 # 获取第一行pdata.loc[0]# 获取第一行指定c1,c2列pdata.loc[0,[c1,c2]] # 获取列索引for item in pdata: print(item) 输出： c1c2c3 # 按列遍历for item in pdata.items(): print(item) 输出： (c1, 0 11 22 3Name: c1, dtype: int64)(c2, 0 41 52 6Name: c2, dtype: int64)(c3, 0 71 82 9Name: c3, dtype: int64) # 按行遍历for item in pdata.iterrows(): print(item) 输出： (0, c1 1c2 4c3 7Name: 0, dtype: int64)(1, c1 2c2 5c3 8Name: 1, dtype: int64)(2, c1 3c2 6c3 9Name: 2, dtype: int64) 3. DataFrame修改# 修改元素import pandas as pddata = c1:[1,2,3], c2:[4,5,6], c3:[7,8,9]pdata = pd.DataFrame(data=data)# 修改c1列值pdata[c1] = 0pdata # DataFrame插入列import pandas as pddata = c1:[1,2,3], c2:[4,5,6], c3:[7,8,9]pdata = pd.DataFrame(data=data)# 修改c1列值pdata[c4] = [-1,-1,-1]pdata # DataFrame插入行import pandas as pddata = c1:[1,2,3], c2:[4,5,6], c3:[7,8,9]pdata = pd.DataFrame(data=data)# 修改c1列值pdata.loc[3] = [-1,-1,-1]pdata","tags":["Pandas"],"categories":["数据处理"]},{"title":"Pandas基础——Series数据结构","path":"/2025/05/07/Pandas基础——Series数据结构/","content":"Series数据结构1. 创建Series对象pd.Series 是 Pandas 库中用于创建一维数组的函数 data: 可以是多种数据类型，如列表、元组、字典、NumPy 数组等 index: 可以是列表、元组等可迭代对象，其长度需要和 data 的长度一致。如果不指定 index，默认会使用从 0 开始的整数作为索引 s_data = pd.Series( data=np.arange(1,4), index=list(abc) )s_data 输出 a 1b 2c 3dtype: int32 2. Series对象访问s_data.iloc[0]s_data.loc[a]s_data[a] 输出 111 3. 获取index与value# 获取索引s_data.index# 获取值s_data.values 输出 Index([a, b, c], dtype=object)array([1, 2, 3]) 4. 将index与value转成列表# 将索引转换成列表s_data.index.tolist()# 将数据转换成列表s_data.values.tolist() 输出 [a, b, c][1, 2, 3] 5. Series对象访问for item in s_data.items(): print(item) 输出 (a, 1)(b, 2)(c, 3)","tags":["Pandas"],"categories":["数据处理"]},{"title":"本地仓库关联GitHub远程仓库","path":"/2025/05/06/本地仓库关联GitHub远程仓库/","content":"步骤一：创建GitHub仓库 登录GitHub 点击右上角的 +，选择 New repository 填写仓库名等信息，点击 Create repository 步骤二：在本地初始化 Git 仓库（如果还没有） cd your-project-foldergit init 步骤三：添加远程仓库地址 复制 GitHub 仓库的地址（HTTPS 或 SSH）： 例如： HTTPS: https://github.com/your-username/your-repo.git SSH: git@github.com:your-username/your-repo.git 在本地仓库中执行： git remote add origin https://github.com/your-username/your-repo.git 或者（用 SSH）： git remote add origin git@github.com:your-username/your-repo.git 步骤四：推送本地代码到 GitHub 第一次推送代码，并设置上游分支： git add .git commit -m Initial commitgit push -u origin master # 如果主分支是 master 或者： git push -u origin main # 如果主分支是 main 检查是否关联成功 运行下面命令查看远程仓库： git remote -v 输出应包含 GitHub 的仓库地址。","tags":["git"],"categories":["开发工具与版本控制"]},{"title":"系统重启cifs自动挂载设置","path":"/2025/04/15/系统重启cifs自动挂载设置/","content":"第一步 为每个账户创建单独的 credentials 文件sudo nano /etc/samba/账户1 内容： username=xxxpassword=xxx 设置权限： sudo chmod 600 /etc/samba/账户1 第二步 编辑 /etc/fstab 文件sudo nano /etc/fstab 在文件末尾添加一行来配置自动挂载： 挂载路径 挂载点 cifs credentials=/etc/samba/用户1,vers=3.0,iocharset=utf8 0 0 挂载路径： 这是共享路径。 挂载点： 本地挂载点，表示挂载的位置。 cifs： 指定使用 CIFS 文件系统（用于挂载网络共享）。 挂载选项： credentials：指定凭据文件。 vers=2.1：指定 SMB 协议版本（如共享服务器使用 SMB 2.1）。 iocharset=utf8：支持中文文件名等 UTF-8 字符。 最后两个数字： 0：转储频率，通常为 0（不转储）。 0：文件系统检查顺序，通常为 0（不检查）。 第三步 测试挂载sudo mount -a 是一种常用的 Linux 命令，主要用于根据 /etc/fstab 文件中的配置挂载所有未挂载的文件系统。 挂载丢失后也可以使用这个命令 sudo mount -a 如果没有报错，可以通过以下命令验证挂载： df -h 第四步 nfs配置使用文本编辑器打开 /etc/fstab 文件： sudo nano /etc/fstab NFS 默认不使用用户名密码，而是依赖 IP 地址和文件系统权限进行控制。 gzeds2.scc.com:/G2AOI/AOI/Archive /home/workspace/AOI/Archive nfs vers=3,tcp,nolock,async,mountproto=tcp,rsize=1048576,wsize=1048576 0 0 服务器路径 gzeds2.scc.com:/G2AOI/AOI/Archive：表示 NFS 服务器地址 gzeds2.scc.com 和共享目录 /G2AOI/AOI/Archive。 本地挂载点 /home/workspace/AOI/Archive：本地挂载目录，挂载成功后，NFS 的内容将显示在此目录下。 文件系统类型 nfs：指定使用 NFS 文件系统挂载。 挂载选项 vers=3：使用 NFSv3 协议。 tcp：使用 TCP 协议代替 UDP，通常更稳定，适合大文件传输。 nolock：禁用文件锁定机制（适用于某些不需要锁的应用场景）。 async：启用异步写入，提高性能。 mountproto=tcp：指定挂载协议为 TCP。 rsize=1048576,wsize=1048576：设置读写缓冲区大小为 1MB，提高传输性能。 0 0 第一个 0：不使用 dump 工具备份。 第二个 0：不检查文件系统。 ​","tags":["Linux"],"categories":["系统配置与运维"]},{"title":"设置samba共享目录","path":"/2025/04/14/设置samba共享目录/","content":"1.检查Samba服务状态sudo systemctl status smbdsudo systemctl status nmbd 输出示例（服务已启动）： ● smbd.service - Samba SMB/CIFS server Loaded: loaded (/lib/systemd/system/smbd.service; enabled; vendor preset: enabled) Active: active (running) since Fri 2025-01-10 10:00:00 UTC; 5min ago 输出示例（服务未启动）： ● smbd.service - Samba SMB/CIFS server Loaded: loaded (/lib/systemd/system/smbd.service; enabled; vendor preset: enabled) Active: inactive (dead) 如果Samba服务未启动，可以使用以下命令启动或重启： sudo systemctl start smbdsudo systemctl start nmbd 重启服务（确保加载最新配置）： sudo systemctl restart smbdsudo systemctl restart nmbd 2. 查看SMB用户使用smbpasswd查看本地SMB用户 sudo pdbedit -L ​\t输出示例 root:0:root 添加SMB用户(必须先是系统用户): sudo smbpasswd -a username 启用用户： sudo smbpasswd -e username 删除SMB用户： sudo smbpasswd -x username 3.编辑 Samba 配置文件 /etc/samba/smb.conf：vim /etc/samba/smb.conf 在文件末尾添加共享配置： [共享目录别名]\tpath = 实际目录绝对路径\tbrowseable = yes\twritable = yes\tguest ok = yes\tcreate mask = 0777\tdirectory mask = 0777 配置解释： path：共享目录路径。 browseable：是否可在网络浏览器中看到该共享。 writable：是否允许写入。 guest ok：是否允许匿名用户访问（无用户名密码）。 create mask 和 directory mask：文件和目录的权限掩码。 如果你希望限制访问，可以在配置中加入： valid users = SMB用户名 重启Samba服务 sudo systemctl restart smbdsudo systemctl restart nmbd 4.挂载测试mount -t cifs //IP地址/共享目录别名 挂载地址 -o vers=3.0,username=SMB账户,password=密码 mount -t cifs //10.65.233.37/vrs_jobs_test /home/workspace/projects/aoi_project/data/vrs_jobs_test -o vers=3.0,username=root,password=Baidu@123","tags":["Linux"],"categories":["系统配置与运维"]},{"title":"腾讯云OpenCloudOS系统下安装ngnix报错","path":"/2025/04/14/腾讯云OpenCloudOS系统下安装ngnix报错/","content":"问题描述： 腾讯云OpenCloudOS 9系统下使用yum安装ngnix时报错 [root@VM-4-7-opencloudos /]# yum install nginx -yLast metadata expiration check: 0:00:41 ago on Mon 14 Apr 2025 01:01:27 AM CST.Error: Problem: cannot install the best candidate for the job - nothing provides libcrypt.so.2()(64bit) needed by nginx-2:1.26.3-1.el9.ngx.x86_64 from nginx-stable - nothing provides libcrypt.so.2(XCRYPT_2.0)(64bit) needed by nginx-2:1.26.3-1.el9.ngx.x86_64 from nginx-stable(try to add --skip-broken to skip uninstallable packages or --nobest to use not only best candidate packages) 解决方法： 用 --nobest 选项尝试安装不那么新的 nginx sudo yum install nginx --nobest -y Installed: nginx-1.26.2-2.oc9.ap.2.x86_64 nginx-core-1.26.2-2.oc9.ap.2.x86_64 nginx-filesystem-1.26.2-2.oc9.ap.2.noarch system-logos-httpd-1.0.4-1.oc9.noarchSkipped: nginx-2:1.26.3-1.el9.ngx.x86_64 这个选项会跳过“最佳匹配”版本，可能会选一个不依赖 libcrypt.so.2 的旧版 nginx。 包名版本 提供方 说明 nginx-1.26.2-2.oc9.ap.2 OpenCloudOS 社区 为 oc9 系统构建，兼容性更好 nginx-1.26.3-1.el9.ngx NGINX 官方 最新稳定版，但可能依赖更新的系统库（比如 libcrypt.so.2）","tags":["Linux"],"categories":["系统配置与运维"]},{"title":"LaTex公式","path":"/2024/07/31/LaTex公式/","content":"","tags":["写作"]},{"title":"charles抓包","path":"/2024/07/02/charles抓包/","content":"Charles抓包安装证书 代理设置","tags":["测试"],"categories":["开发工具与版本控制"]},{"title":"陈","path":"/2024/06/20/陈/","content":"龙门——陈 龙门近卫局警司，特别督察组组长。 负责龙门近卫局特别督察组的日常指挥执行工作。 魏彦吾的最得力的下属之一。拥有整个近卫局中最精湛的剑技以及最严苛的态度。态度极度强硬，对人一视同仁。看起来一点都不变通，总是一副凶着脸的样子。 武器陈警司的爱剑名为“赤霄”，这并不是一个秘密。但鲜少有人知道，赤霄有七式——拔刀、泪锋、奔夜、扬眉、绝影、云裂、天瞠（cheng) 至于陈警司是不愿使用还是不能使用，恐怕就只有她本人知晓了 陈证章 干员陈擅长于近身搏斗中对敌人造成多段杀伤 根据外勤部门决议 在外勤任务中划分为近卫干员，行使剑豪职责 特别颁发此证章 以兹证明 招聘合同龙门近卫局特别督察组组长陈，正依合约前来协助罗德岛的任务。 生气的时候很可怕，平常也最好别惹她。 信物在漫长时光中尘封许久的物件。 她并非是将之忘记，而仅仅是不忍再次抚摸它锈蚀的棱角 兴许在某一天，它会重新焕发出过往的炽热吧。 罗德岛制式剑 基础信息 七月七，晴。生辰，她激动地想要为魏彦吾展示拔刀，却找不到魏彦吾的踪影。等了三天，没有等到。 五月十三，多云。以泪锋斩断了庭中的三十年老树，砸坏了屋顶。魏彦吾没有出现，只是差人植了一棵新的。她不再期待魏彦吾的认可。 一月一，大雨。贺年，倾盆大雨，去贫民区的途中路见不平，愤而出手，以一敌十五。生死攸关之际，以随身佩剑递出奔夜，伤七人，退八人。闹到了上面，魏彦吾难得出现，看了剑痕后，只看她一眼就走了。她忘了自己当时为何出手，却永远不会忘记那一眼中的失望。 十二月二十五，晴。从近卫学院返乡路上见义勇为，浑然无惧，扬眉之剑，当放则放。她意气风发，以为自己可以荡平天下不平事。 七月三十，多云。以昏迷五天为代价，递出绝影，最终斩了重大通缉犯，龙门陈晖洁，崭露头角。醒来之后，赤霄放在她的床头，魏彦吾没有来看过她。 八月十三，阴。追捕感染者罪犯途中，欲以赤霄出手，赤霄纹丝未动。而后，生死攸关之际，福至心灵，赤霄拔刀，斩塌了半个地下车库。她去找魏彦吾想知道赤霄究竟为何，魏彦吾没有见她。 九月三十，晴。赤霄二度出鞘，斩开一扇金库大门，救出其中人质。她开始理解，赤霄乃意志之剑。她以为她一直以来做得够多，其实是她做得太少。她必须更快，她必须更有力。 七月七，多云。生辰，十几年来，魏彦吾第一次提出要看一看她的剑，她凝聚一路所学，以未完成的云裂作为答卷，魏彦吾不置可否。 一月十一，晴。与罗德岛一同离开龙门。之后一路，赤霄鲜少出鞘。 往昔时光 大地的伤痕自天际线奔袭而来，精准地击中一片维多利亚式建筑群，楼宇如同遭遇旋风袭击的树林，围绕着同一个点以放射状倒塌。在这片帝国的废墟之中，两个身影正翻过一座倒下的石碑，试图寻找高点。 “这里荒废多久了？”陈站在废墟上远眺，身后的石碑上那些曾经象征着荣誉的名字都被涂抹殆尽。 “这片校舍自从战争爆发那会儿就弃用了，还没完成学业的学弟学妹们被分流到了新的校区，完成了剩下的课程……陈陈，前面是我们以前的老训练场，你还记得吗？”风笛的声音从低处传来。 “我记得特别清楚，感觉自己当学生的时候总是错过一些好事。一到毕业路也修好了，训练场也修好了。” 训练场被冲击波挤成了一片片翘起的地块，陈捡起了一块石头，丢进地块夹缝中冒出的灌木丛，躲在其中的羽兽尖叫着扑腾向远处。 “那时候已经足够好啦。”风笛的声音自远而近，停留在了陈的耳畔。 “也是。那可能是我最单纯的一段时间了，不用去思考一些麻烦的问题，只需要专心训练和学习。” “这就是当时的你每天疯狂训练，全常规科目拿A的动力？”风笛将双手搭在陈的肩上，轻轻地摇晃着。 “回去以后，我发现有太多的事无法用刀剑解决，有些时候会觉得自己过于渺小，即便努力工作，也无法改变很多事——消灭敌人有的时候并不能解决问题。”陈摇了摇头，好像要把过去的庞杂思绪都从脑海中丢出去。 两人走下高坡，记忆中的花圃还在原地。 曾经高悬的近卫学校标志一半深深插入泥土，一半斜靠在断裂的石柱上。夕阳西下，阳光倾泻在已有斑驳锈迹的标志上，仅剩的金属光泽诉说着这里曾经的荣光。 “一切都变了，维多利亚不也一样吗？”陈盯着校徽，喃喃自语道。 “还是有人没有变的。知道你要来，我前几天特意去拜访了泰勒教官。当时你走得太匆忙，留在宿舍里的文件啥的都没带走——她这些年一直保管着你这些东西。 这是你的学业通过证明。哦对了，还有这个！” 风笛从随身的包里掏出了一叠证件，还有一把木剑。 “这是你当年的训练用剑，按道理是要收回的，但是你的成绩太好了，教官本来打算给你个惊喜，想把这把剑送给你……” “代我向她表示感谢。那会儿我走得太快了……” “至少你现在回来了。这些年，我们很多同学再也没有回来。” 两人沉默了一会儿。 “十年后，你觉得你会在哪？” “谁知道呢，应该要回去吧，还有很多事要做。”陈向远方看去，那正是龙门的方向，“那时无论来这上学还是离开，都是他们安排好的。现在，我要自己走回去了。”","categories":["明日方舟"]},{"title":"虚拟机静态ip配置","path":"/2024/06/04/虚拟机静态ip配置/","content":"第一步打开虚拟机，点击导航栏上面的 编辑–虚拟网络编辑器 第二步选中上面的VMnet8，在到下面的子网 ip 处编辑ip地址，可以改成192.168.8.0，点击右边的 NAT设置 第三步在NAT中设置网关 i p，可以改成 192.168.8.2，点击确定就可以了， 配置【网关ip】，注意【网关ip】需要在【子网ip】段下，这里设置为192.168.8.2，请不要设置为192.168.8.1，否则会出错。 第四步在电脑的任务栏中选中网络那里右键打开 网络和共享中心 在左边点击 更改适配器设置，然后右键选属性打开 VMare Network Adapter VMnet8, 在打开的页面上选 Internet协议版本4 点击属性，在打开的页面选择 使用下面的ip地址 ip地址可以填192.168.8.1，默认网关必须与前面的第三步配好的网关ip一致也就是 192.168.8.2，就此虚拟机的固定ip地址就配完了 第五步到linux操作系统中输入命令 vi etcsysconfignetwork-scriptsifcfg-ens33 TYPEEthernetPROXY_METHODnoneBROWSER_ONLYnoBOOTPROTOstatic #dhcp修改为staticDEFROUTEyesIPV4_FAILURE_FATALnoIPV6INITyesIPV6_AUTOCONFyesIPV6_DEFROUTEyesIPV6_FAILURE_FATALnoIPV6_ADDR_GEN_MODEstable-privacyNAMEens33#HWADDR00:0C:39:82:D2:E1 #mac地址UUIDe9fc8134-2e3f-480c-99db-012d118df87bDEVICEens33ONBOOTyesIPADDR192.168.8.101 #静态IP，跟192.168.8的网段相同，但不能与192.168.8.1一样会冲突NETMASK255.255.255.0 #子网 掩码GATEWAY192.168.8.2 #网关DNS1192.168.8.2 #DNS配置与网关一致 改好后保存退出，重启网卡： systemctl restart network ifconfig 回车查看ip地址： 可以输入ping www.baidu.com看看是否能ping通百度，下面个的图片已经可以ping通百度了，这时候按ctrl+Z键可以停止","tags":["Linux"],"categories":["系统配置与运维"]},{"title":"K8S虚拟机集群配置","path":"/2024/05/31/K8S虚拟机集群配置/","content":"一、基本环境准备工作设置hostname hostnamectl set-hostname master hostnamectl set-hostname node1 hostnamectl set-hostname node2 关闭防火墙 systemctl stop firewalldsystemctl disable firewalld 查看ip ip addr master：192.168.19.101 node1： 192.168.19.102 node2： 192.168.19.103 设置host和ip绑定 vim /etc/hosts 三个节点相互可以ping通 ping masterping node1ping node2 系统初始化 关闭selinux sed -i s/enforcing/disabled/ /etc/selinux/config # 永久setenforce 0 # 临时 关闭 swap swapoff -a # 临时vim /etc/fstab # 永久 将桥接的 IPv4 流量传递到 iptables 的链 # 配置cat /etc/sysctl.d/k8s.conf EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 生效sysctl --system 时间同步 yum install ntpdate -yntpdate time.windows.com 二、所有节点安装 DockerkubeadmkubeletKubernetes 默认 CRI（容器运行时）为 Docker，因此先安装 Docker。 （1）安装 Dockerwget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repoyum -y install docker-ce-18.06.1.ce-3.el7systemctl enable docker systemctl start dockerdocker --version （2）添加阿里云 YUM 软件源设置仓库地址 cat /etc/docker/daemon.json EOFregistry-mirrors: [https://b9pmyelo.mirror.aliyuncs.com]EOF 添加 yum 源 cat /etc/yum.repos.d/kubernetes.repo EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpghttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF （3）安装 kubeadm，kubelet 和 kubectlyum install -y kubelet kubeadm kubectlsystemctl enable kubelet 三、部署 Kubernetes Master在 192.168.19.101（Master）执行 kubeadm init --apiserver-advertise-address=192.168.19.101 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.23.6 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16 安装成功后，复制如下配置并执行 mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/configkubectl get nodes 四、加入 Kubernets Node获取master节点的token 如果 token 已经过期，就重新申请 kubeadm token create token 没有过期可以通过如下命令获取 kubeadm token list 获取 –discovery-token-ca-cert-hash 值，得到值后需要在前面拼接上 sha256: openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2/dev/null | \\openssl dgst -sha256 -hex | sed s/^.* // 在node节点输入 kubeadm join 192.168.19.101:6443 --token 01ypzs.0af41ttdb3o6ush9 --discovery-token-ca-cert-hash sha256:7b01f7fe1f03a38b845c506eccad67e30f781ac6cc7877e00af45f33b8b3cdf4 查看nodes 输入kubectl get componentstatus查看组件状态 输入kubectl get pods查看pod 输入kubectl get pods -n kube-system查看指定命名空间的pod 最上面两个pod没用准备好是因为没有网络 五、部署CNI网络插件在opt下创建k8s文件夹 在optk8s下 curl https://calico-v3-25.netlify.app/archive/v3.25/manifests/calico.yaml -O 修改 calico.yaml 文件中的 CALICO_IPV4POOL_CIDR 配置，修改为与初始化的 cidr 相同 修改calico.yaml 文件中的 镜像地址 sed -i s#docker.io/##g calico.yaml 构建应用 kubectl apply -f calico.yaml","tags":["K8S"],"categories":["系统配置与运维"]}]